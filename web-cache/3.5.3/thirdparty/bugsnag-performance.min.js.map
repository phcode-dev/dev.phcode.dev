{"version":3,"file":"bugsnag-performance.min.js","sources":["../packages/core/dist/validation.js","../packages/core/dist/attributes.js","../packages/core/dist/clock.js","../packages/core/dist/config.js","../packages/core/dist/batch-processor.js","../packages/core/dist/events.js","../packages/core/dist/span.js","../packages/core/dist/trace-id-to-sampling-rate.js","../packages/core/dist/delivery.js","../packages/core/dist/probability-fetcher.js","../packages/core/dist/probability-manager.js","../packages/core/dist/processor.js","../packages/core/dist/sampler.js","../packages/core/dist/span-context.js","../packages/core/dist/time.js","../packages/core/dist/span-factory.js","../packages/core/dist/persistence.js","../packages/core/dist/retry-queue.js","../packages/delivery-fetch/dist/delivery.js","../packages/request-tracker/dist/network-request-callback.js","../packages/request-tracker/dist/request-tracker.js","../packages/request-tracker/dist/url-helpers.js","../packages/request-tracker/dist/request-tracker-fetch.js","../packages/platforms/browser/lib/send-page-attributes.ts","../packages/platforms/browser/lib/auto-instrumentation/page-load-phase-spans.ts","../packages/platforms/browser/lib/default-routing-provider.ts","../packages/platforms/browser/lib/auto-instrumentation/full-page-load-plugin.ts","../packages/platforms/browser/lib/auto-instrumentation/network-request-plugin.ts","../packages/platforms/browser/lib/auto-instrumentation/resource-load-plugin.ts","../packages/platforms/browser/lib/auto-instrumentation/route-change-plugin.ts","../packages/platforms/browser/lib/clock.ts","../packages/platforms/browser/lib/routing-provider.ts","../packages/platforms/browser/lib/id-generator.ts","../packages/platforms/browser/lib/on-settle/settler.ts","../packages/platforms/browser/lib/on-settle/dom-mutation-settler.ts","../packages/platforms/browser/lib/on-settle/load-event-end-settler.ts","../packages/platforms/browser/lib/on-settle/request-settler.ts","../packages/platforms/browser/lib/on-settle/settler-aggregate.ts","../packages/platforms/browser/lib/persistence.ts","../node_modules/@bugsnag/cuid/lib/pad.js","../node_modules/@bugsnag/cuid/lib/fingerprint.browser.js","../node_modules/@bugsnag/cuid/index.js","../packages/platforms/browser/lib/web-vitals.ts","../packages/platforms/browser/lib/browser.ts","../packages/platforms/browser/lib/on-settle/index.ts","../packages/core/dist/core.js","../packages/platforms/browser/lib/backgrounding-listener.ts","../packages/platforms/browser/lib/span-attributes-source.ts","../packages/platforms/browser/lib/resource-attributes-source.ts","../packages/request-tracker/dist/request-tracker-xhr.js","../packages/platforms/browser/lib/config.ts"],"sourcesContent":["const isBoolean = (value) => value === true || value === false;\nconst isObject = (value) => !!value && typeof value === 'object' && !Array.isArray(value);\nconst isNumber = (value) => typeof value === 'number' && Number.isFinite(value) && !Number.isNaN(value);\nconst isString = (value) => typeof value === 'string';\nconst isStringWithLength = (value) => isString(value) && value.length > 0;\nconst isLogger = (value) => isObject(value) &&\n    typeof value.debug === 'function' &&\n    typeof value.info === 'function' &&\n    typeof value.warn === 'function' &&\n    typeof value.error === 'function';\nconst isStringArray = (value) => Array.isArray(value) && value.every(isStringWithLength);\nconst isStringOrRegExpArray = (value) => Array.isArray(value) && value.every(item => isStringWithLength(item) || item instanceof RegExp);\nfunction isPersistedProbability(value) {\n    return isObject(value) &&\n        isNumber(value.value) &&\n        isNumber(value.time);\n}\nconst isSpanContext = (value) => isObject(value) &&\n    typeof value.id === 'string' &&\n    typeof value.traceId === 'string' &&\n    typeof value.isValid === 'function';\nfunction isTime(value) {\n    return isNumber(value) || value instanceof Date;\n}\n// NOTE: this should be kept in sync with the notifier\n// https://github.com/bugsnag/bugsnag-js/blob/next/packages/plugin-browser-device/device.js\nfunction isDeviceId(value) {\n    // make sure the persisted value looks like a valid cuid\n    return typeof value === 'string' && /^c[a-z0-9]{20,32}$/.test(value);\n}\nfunction isPlugin(value) {\n    return isObject(value) && typeof value.configure === 'function';\n}\nfunction isPluginArray(value) {\n    return Array.isArray(value) && value.every(plugin => isPlugin(plugin));\n}\n\nexport { isBoolean, isDeviceId, isLogger, isNumber, isObject, isPersistedProbability, isPlugin, isPluginArray, isSpanContext, isString, isStringArray, isStringOrRegExpArray, isStringWithLength, isTime };\n","import { isNumber } from './validation.js';\n\nclass SpanAttributes {\n    constructor(initialValues) {\n        this.attributes = initialValues;\n    }\n    set(name, value) {\n        if (typeof value === 'string' || typeof value === 'boolean' || isNumber(value)) {\n            this.attributes.set(name, value);\n        }\n    }\n    remove(name) {\n        this.attributes.delete(name);\n    }\n    toJson() {\n        return Array.from(this.attributes).map(([key, value]) => attributeToJson(key, value));\n    }\n}\nclass ResourceAttributes extends SpanAttributes {\n    constructor(releaseStage, appVersion, sdkName, sdkVersion) {\n        const initialValues = new Map([\n            ['deployment.environment', releaseStage],\n            ['telemetry.sdk.name', sdkName],\n            ['telemetry.sdk.version', sdkVersion]\n        ]);\n        if (appVersion.length > 0) {\n            initialValues.set('service.version', appVersion);\n        }\n        super(initialValues);\n    }\n}\nfunction attributeToJson(key, attribute) {\n    switch (typeof attribute) {\n        case 'number':\n            if (Number.isNaN(attribute) || !Number.isFinite(attribute)) {\n                return undefined;\n            }\n            // 'bugsnag.sampling.p' must always be sent as a doubleValue\n            if (key !== 'bugsnag.sampling.p' && Number.isInteger(attribute)) {\n                return { key, value: { intValue: `${attribute}` } };\n            }\n            return { key, value: { doubleValue: attribute } };\n        case 'boolean':\n            return { key, value: { boolValue: attribute } };\n        case 'string':\n            return { key, value: { stringValue: attribute } };\n        default:\n            return undefined;\n    }\n}\n\nexport { ResourceAttributes, SpanAttributes, attributeToJson };\n","const NANOSECONDS_IN_MILLISECONDS = 1000000;\nfunction millisecondsToNanoseconds(milliseconds) {\n    return Math.round(milliseconds * NANOSECONDS_IN_MILLISECONDS);\n}\n\nexport { millisecondsToNanoseconds };\n","import { isStringWithLength, isString, isLogger, isStringArray, isNumber, isPluginArray, isObject } from './validation.js';\n\nconst schema = {\n    appVersion: {\n        defaultValue: '',\n        message: 'should be a string',\n        validate: isStringWithLength\n    },\n    endpoint: {\n        defaultValue: 'https://otlp.bugsnag.com/v1/traces',\n        message: 'should be a string',\n        validate: isStringWithLength\n    },\n    apiKey: {\n        defaultValue: '',\n        message: 'should be a 32 character hexadecimal string',\n        validate: (value) => isString(value) && /^[a-f0-9]{32}$/.test(value)\n    },\n    logger: {\n        defaultValue: {\n            debug(message) { console.debug(message); },\n            info(message) { console.info(message); },\n            warn(message) { console.warn(message); },\n            error(message) { console.error(message); }\n        },\n        message: 'should be a Logger object',\n        validate: isLogger\n    },\n    releaseStage: {\n        defaultValue: 'production',\n        message: 'should be a string',\n        validate: isStringWithLength\n    },\n    enabledReleaseStages: {\n        defaultValue: null,\n        message: 'should be an array of strings',\n        validate: (value) => value === null || isStringArray(value)\n    },\n    samplingProbability: {\n        defaultValue: 1.0,\n        message: 'should be a number between 0 and 1',\n        validate: (value) => isNumber(value) && value >= 0 && value <= 1\n    },\n    plugins: {\n        defaultValue: [],\n        message: 'should be an array of plugin objects',\n        validate: isPluginArray\n    }\n};\nfunction validateConfig(config, schema) {\n    if (typeof config === 'string') {\n        config = { apiKey: config };\n    }\n    if (!isObject(config) || !isString(config.apiKey) || config.apiKey.length === 0) {\n        throw new Error('No Bugsnag API Key set');\n    }\n    let warnings = '';\n    const cleanConfiguration = {};\n    for (const option of Object.keys(schema)) {\n        if (Object.prototype.hasOwnProperty.call(config, option)) {\n            if (schema[option].validate(config[option])) {\n                cleanConfiguration[option] = config[option];\n            }\n            else {\n                warnings += `\\n  - ${option} ${schema[option].message}, got ${typeof config[option]}`;\n                cleanConfiguration[option] = schema[option].defaultValue;\n            }\n        }\n        else {\n            cleanConfiguration[option] = schema[option].defaultValue;\n        }\n    }\n    // If apiKey is set but not valid we should still use it, despite the validation warning.\n    cleanConfiguration.apiKey = config.apiKey;\n    cleanConfiguration.maximumBatchSize = config.maximumBatchSize || 100;\n    cleanConfiguration.batchInactivityTimeoutMs = config.batchInactivityTimeoutMs || 30 * 1000;\n    if (warnings.length > 0) {\n        cleanConfiguration.logger.warn(`Invalid configuration${warnings}`);\n    }\n    return cleanConfiguration;\n}\n\nexport { schema, validateConfig };\n","class BatchProcessor {\n    constructor(delivery, configuration, retryQueue, sampler, probabilityManager, encoder) {\n        this.batch = [];\n        this.timeout = null;\n        this.delivery = delivery;\n        this.configuration = configuration;\n        this.retryQueue = retryQueue;\n        this.sampler = sampler;\n        this.probabilityManager = probabilityManager;\n        this.encoder = encoder;\n        this.flush = this.flush.bind(this);\n    }\n    stop() {\n        if (this.timeout !== null) {\n            clearTimeout(this.timeout);\n            this.timeout = null;\n        }\n    }\n    start() {\n        this.stop();\n        this.timeout = setTimeout(this.flush, this.configuration.batchInactivityTimeoutMs);\n    }\n    add(span) {\n        if (this.configuration.enabledReleaseStages &&\n            !this.configuration.enabledReleaseStages.includes(this.configuration.releaseStage)) {\n            return;\n        }\n        this.batch.push(span);\n        if (this.batch.length >= this.configuration.maximumBatchSize) {\n            this.flush();\n        }\n        else {\n            this.start();\n        }\n    }\n    async flush() {\n        this.stop();\n        const batch = this.prepareBatch();\n        // we either had nothing in the batch originally or all spans were discarded\n        if (!batch) {\n            return;\n        }\n        const payload = await this.encoder.encode(batch);\n        const batchTime = Date.now();\n        try {\n            const response = await this.delivery.send(payload);\n            if (response.samplingProbability !== undefined) {\n                this.probabilityManager.setProbability(response.samplingProbability);\n            }\n            switch (response.state) {\n                case 'success':\n                    this.retryQueue.flush();\n                    break;\n                case 'failure-discard':\n                    this.configuration.logger.warn('delivery failed');\n                    break;\n                case 'failure-retryable':\n                    this.configuration.logger.info('delivery failed, adding to retry queue');\n                    this.retryQueue.add(payload, batchTime);\n                    break;\n                default:\n                    response.state;\n            }\n        }\n        catch (err) {\n            this.configuration.logger.warn('delivery failed');\n        }\n    }\n    prepareBatch() {\n        if (this.batch.length === 0) {\n            return;\n        }\n        // update sampling values if necessary and re-sample\n        const batch = [];\n        const probability = this.sampler.spanProbability;\n        for (const span of this.batch) {\n            if (span.samplingProbability.raw > probability.raw) {\n                span.samplingProbability = probability;\n            }\n            if (this.sampler.sample(span)) {\n                batch.push(span);\n            }\n        }\n        // clear out the current batch so we're ready to start a new one\n        this.batch = [];\n        // if every span was discarded there's nothing to send\n        if (batch.length === 0) {\n            return;\n        }\n        return batch;\n    }\n}\n\nexport { BatchProcessor };\n","class SpanEvents {\n    constructor() {\n        this.events = [];\n    }\n    add(name, time) {\n        this.events.push({ name, time });\n    }\n    toJson(clock) {\n        return this.events.map(({ name, time }) => ({ name, timeUnixNano: clock.toUnixTimestampNanoseconds(time) }));\n    }\n}\n\nexport { SpanEvents };\n","import { SpanEvents } from './events.js';\nimport traceIdToSamplingRate from './trace-id-to-sampling-rate.js';\nimport { isTime, isSpanContext, isBoolean } from './validation.js';\n\nfunction spanToJson(span, clock) {\n    return {\n        name: span.name,\n        kind: span.kind,\n        spanId: span.id,\n        traceId: span.traceId,\n        parentSpanId: span.parentSpanId,\n        startTimeUnixNano: clock.toUnixTimestampNanoseconds(span.startTime),\n        endTimeUnixNano: clock.toUnixTimestampNanoseconds(span.endTime),\n        attributes: span.attributes.toJson(),\n        events: span.events.toJson(clock)\n    };\n}\nclass SpanInternal {\n    constructor(id, traceId, name, startTime, attributes, parentSpanId) {\n        this.kind = 3 /* Kind.Client */; // TODO: How do we define the initial Kind?\n        this.events = new SpanEvents();\n        this.id = id;\n        this.traceId = traceId;\n        this.parentSpanId = parentSpanId;\n        this.name = name;\n        this.startTime = startTime;\n        this.attributes = attributes;\n        this.samplingRate = traceIdToSamplingRate(this.traceId);\n    }\n    addEvent(name, time) {\n        this.events.add(name, time);\n    }\n    setAttribute(name, value) {\n        this.attributes.set(name, value);\n    }\n    end(endTime, samplingProbability) {\n        this.endTime = endTime;\n        let _samplingProbability = samplingProbability;\n        this.attributes.set('bugsnag.sampling.p', _samplingProbability.raw);\n        return {\n            id: this.id,\n            name: this.name,\n            kind: this.kind,\n            traceId: this.traceId,\n            startTime: this.startTime,\n            attributes: this.attributes,\n            events: this.events,\n            samplingRate: this.samplingRate,\n            endTime,\n            get samplingProbability() {\n                return _samplingProbability;\n            },\n            set samplingProbability(samplingProbability) {\n                _samplingProbability = samplingProbability;\n                this.attributes.set('bugsnag.sampling.p', _samplingProbability.raw);\n            },\n            parentSpanId: this.parentSpanId\n        };\n    }\n    isValid() {\n        return this.endTime === undefined;\n    }\n}\nconst coreSpanOptionSchema = {\n    startTime: {\n        message: 'should be a number or Date',\n        getDefaultValue: () => undefined,\n        validate: isTime\n    },\n    parentContext: {\n        message: 'should be a SpanContext',\n        getDefaultValue: () => undefined,\n        validate: (value) => value === null || isSpanContext(value)\n    },\n    makeCurrentContext: {\n        message: 'should be true|false',\n        getDefaultValue: () => undefined,\n        validate: isBoolean\n    },\n    isFirstClass: {\n        message: 'should be true|false',\n        getDefaultValue: () => undefined,\n        validate: isBoolean\n    }\n};\n\nexport { SpanInternal, coreSpanOptionSchema, spanToJson };\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// taken from OpenTelemetry's TraceIdRatioBasedSampler:\n// https://github.com/open-telemetry/opentelemetry-js/blob/ca700c4eef64c14bb5fef2be6f08ace7973a8881/packages/opentelemetry-sdk-trace-base/src/sampler/TraceIdRatioBasedSampler.ts#L47-L55\n// with some small modifications to match our naming conventions\nfunction traceIdToSamplingRate(traceId) {\n    let samplingRate = 0;\n    for (let i = 0; i < traceId.length / 8; i++) {\n        const position = i * 8;\n        const segment = Number.parseInt(traceId.slice(position, position + 8), 16);\n        samplingRate = (samplingRate ^ segment) >>> 0;\n    }\n    return samplingRate;\n}\n\nexport { traceIdToSamplingRate as default };\n","import { spanToJson } from './span.js';\n\nclass TracePayloadEncoder {\n    constructor(clock, configuration, resourceAttributeSource) {\n        this.clock = clock;\n        this.configuration = configuration;\n        this.resourceAttributeSource = resourceAttributeSource;\n    }\n    async encode(spans) {\n        const resourceAttributes = await this.resourceAttributeSource(this.configuration);\n        const jsonSpans = Array(spans.length);\n        for (let i = 0; i < spans.length; ++i) {\n            jsonSpans[i] = spanToJson(spans[i], this.clock);\n        }\n        const deliveryPayload = {\n            resourceSpans: [\n                {\n                    resource: { attributes: resourceAttributes.toJson() },\n                    scopeSpans: [{ spans: jsonSpans }]\n                }\n            ]\n        };\n        return {\n            body: deliveryPayload,\n            headers: {\n                'Bugsnag-Api-Key': this.configuration.apiKey,\n                'Content-Type': 'application/json',\n                'Bugsnag-Span-Sampling': this.generateSamplingHeader(spans)\n            }\n        };\n    }\n    generateSamplingHeader(spans) {\n        if (spans.length === 0) {\n            return '1:0';\n        }\n        const spanCounts = Object.create(null);\n        for (const span of spans) {\n            const existingValue = spanCounts[span.samplingProbability.raw] || 0;\n            spanCounts[span.samplingProbability.raw] = existingValue + 1;\n        }\n        const rawProbabilities = Object.keys(spanCounts);\n        const pairs = Array(rawProbabilities.length);\n        for (let i = 0; i < rawProbabilities.length; ++i) {\n            const rawProbability = rawProbabilities[i];\n            pairs[i] = `${rawProbability}:${spanCounts[rawProbability]}`;\n        }\n        return pairs.join(';');\n    }\n}\nconst retryCodes = new Set([402, 407, 408, 429]);\nfunction responseStateFromStatusCode(statusCode) {\n    if (statusCode >= 200 && statusCode < 300) {\n        return 'success';\n    }\n    if (statusCode >= 400 && statusCode < 500 && !retryCodes.has(statusCode)) {\n        return 'failure-discard';\n    }\n    return 'failure-retryable';\n}\n\nexport { TracePayloadEncoder, responseStateFromStatusCode };\n","// the time to wait before retrying a failed request\nconst RETRY_MILLISECONDS = 30 * 1000;\nclass ProbabilityFetcher {\n    constructor(delivery, apiKey) {\n        this.delivery = delivery;\n        this.payload = {\n            body: { resourceSpans: [] },\n            headers: {\n                'Bugsnag-Api-Key': apiKey,\n                'Content-Type': 'application/json',\n                'Bugsnag-Span-Sampling': '1.0:0'\n            }\n        };\n    }\n    async getNewProbability() {\n        // keep making requests until we get a new probability value from the server\n        while (true) {\n            const response = await this.delivery.send(this.payload);\n            // in theory this should always be present, but it's possible the request\n            // fails or there's a bug on the server side causing it not to be returned\n            if (response.samplingProbability !== undefined) {\n                return response.samplingProbability;\n            }\n            await this.timeBetweenRetries();\n        }\n    }\n    timeBetweenRetries() {\n        return new Promise(resolve => {\n            setTimeout(resolve, RETRY_MILLISECONDS);\n        });\n    }\n}\n\nexport { ProbabilityFetcher as default };\n","// the time between requests to fetch a new probability value from the server\nconst PROBABILITY_REFRESH_MILLISECONDS = 24 * 60 * 60 * 1000; // 24 hours\nclass ProbabilityManager {\n    static async create(persistence, sampler, probabilityFetcher) {\n        const persistedProbability = await persistence.load('bugsnag-sampling-probability');\n        let initialProbabilityTime;\n        let initialTimoutDuration;\n        if (persistedProbability === undefined) {\n            // If there is no stored probability:\n            // - Set the initial probability value to the default\n            sampler.probability = 1.0;\n            initialProbabilityTime = 0;\n            // - Immediately fetch a new probability value\n            initialTimoutDuration = 0;\n        }\n        else if (persistedProbability.time < Date.now() - PROBABILITY_REFRESH_MILLISECONDS) {\n            // If it is >= 24 hours old:\n            // - Set the initial probability value to the stored value\n            sampler.probability = persistedProbability.value;\n            initialProbabilityTime = persistedProbability.time;\n            // - Immediately fetch a new probability value\n            initialTimoutDuration = 0;\n        }\n        else {\n            // If it is < 24 hours old:\n            // - Use the stored probability\n            sampler.probability = persistedProbability.value;\n            initialProbabilityTime = persistedProbability.time;\n            // - Fetch a new probability when this value would be 24 hours old\n            initialTimoutDuration = PROBABILITY_REFRESH_MILLISECONDS - (Date.now() - initialProbabilityTime);\n        }\n        return new ProbabilityManager(persistence, sampler, probabilityFetcher, initialTimoutDuration, initialProbabilityTime);\n    }\n    constructor(persistence, sampler, probabilityFetcher, initialTimoutDuration, initialProbabilityTime) {\n        this.timeout = undefined;\n        this.persistence = persistence;\n        this.sampler = sampler;\n        this.probabilityFetcher = probabilityFetcher;\n        this.lastProbabilityTime = initialProbabilityTime;\n        this.fetchNewProbabilityIn(initialTimoutDuration);\n    }\n    setProbability(newProbability) {\n        this.lastProbabilityTime = Date.now();\n        this.sampler.probability = newProbability;\n        this.fetchNewProbabilityIn(PROBABILITY_REFRESH_MILLISECONDS);\n        // return this promise for convience in unit tests as it allows us to wait\n        // for persistence to finish; in real code we won't ever wait for this but\n        // there's no harm in returning it anyway\n        return this.persistence.save('bugsnag-sampling-probability', {\n            value: newProbability,\n            time: this.lastProbabilityTime\n        });\n    }\n    fetchNewProbabilityIn(milliseconds) {\n        clearTimeout(this.timeout);\n        const lastProbabilityTimeBeforeTimeout = this.lastProbabilityTime;\n        this.timeout = setTimeout(async () => {\n            const probability = await this.probabilityFetcher.getNewProbability();\n            // only apply the new probability if we haven't received another value\n            // in the meantime, e.g. from a trace request's response\n            if (lastProbabilityTimeBeforeTimeout === this.lastProbabilityTime) {\n                this.setProbability(probability);\n            }\n        }, milliseconds);\n    }\n}\n\nexport { ProbabilityManager as default };\n","// a processor that buffers spans in memory until the client has started\n// not sure if this would need to be platform specific — will we ever care about\n// persisting spans if 'start' is never called?\nclass BufferingProcessor {\n    constructor() {\n        this.spans = [];\n    }\n    add(span) {\n        this.spans.push(span);\n    }\n}\n\nexport { BufferingProcessor };\n","// sampling rates are stored as a number between 0 and 2^32 - 1 (i.e. they are\n// u32s) so we need to scale the probability value to match this range as they\n// are stored as values between 0 and 1\nfunction scaleProbabilityToMatchSamplingRate(probability) {\n    return Math.floor(probability * 0xffffffff);\n}\nclass Sampler {\n    constructor(initialProbability) {\n        // we could just do 'this.probability = initialProbability' but TypeScript\n        // doesn't like that as it doesn't directly initialise these properties in\n        // the constructor\n        this._probability = initialProbability;\n        this.scaledProbability = scaleProbabilityToMatchSamplingRate(initialProbability);\n    }\n    /**\n     * The global probability value: a number between 0 & 1\n     */\n    get probability() {\n        return this._probability;\n    }\n    set probability(probability) {\n        this._probability = probability;\n        this.scaledProbability = scaleProbabilityToMatchSamplingRate(probability);\n    }\n    /**\n     * The probability value for spans: a number between 0 & 2^32 - 1\n     *\n     * This is necessary because span sampling rates are generated as unsigned 32\n     * bit integers. We scale the global probability value to match that range, so\n     * that we can use a simple calculation in 'sample'\n     *\n     * @see scaleProbabilityToMatchSamplingRate\n     */\n    get spanProbability() {\n        return {\n            raw: this._probability,\n            scaled: this.scaledProbability\n        };\n    }\n    sample(span) {\n        return span.samplingRate <= span.samplingProbability.scaled;\n    }\n}\n\nexport { Sampler as default };\n","function spanContextEquals(span1, span2) {\n    if (span1 === span2)\n        return true;\n    if (span1 !== undefined && span2 !== undefined) {\n        return span1.id === span2.id && span1.traceId === span2.traceId;\n    }\n    return false;\n}\nclass DefaultSpanContextStorage {\n    constructor(backgroundingListener, contextStack = []) {\n        this.isInForeground = true;\n        this.onBackgroundStateChange = (state) => {\n            this.isInForeground = state === 'in-foreground';\n            // clear the context stack regardless of the new background state\n            // since spans are only valid if they start and end while the app is in the foreground\n            this.contextStack.length = 0;\n        };\n        this.contextStack = contextStack;\n        backgroundingListener.onStateChange(this.onBackgroundStateChange);\n    }\n    *[Symbol.iterator]() {\n        for (let i = this.contextStack.length - 1; i >= 0; --i) {\n            yield this.contextStack[i];\n        }\n    }\n    push(context) {\n        if (context.isValid() && this.isInForeground) {\n            this.contextStack.push(context);\n        }\n    }\n    pop(context) {\n        if (spanContextEquals(context, this.current)) {\n            this.contextStack.pop();\n        }\n        this.removeClosedContexts();\n    }\n    get first() {\n        this.removeClosedContexts();\n        return this.contextStack.length > 0\n            ? this.contextStack[0]\n            : undefined;\n    }\n    get current() {\n        this.removeClosedContexts();\n        return this.contextStack.length > 0\n            ? this.contextStack[this.contextStack.length - 1]\n            : undefined;\n    }\n    removeClosedContexts() {\n        while (this.contextStack.length > 0 &&\n            this.contextStack[this.contextStack.length - 1].isValid() === false) {\n            this.contextStack.pop();\n        }\n    }\n}\n\nexport { DefaultSpanContextStorage, spanContextEquals };\n","import { isNumber } from './validation.js';\n\nfunction timeToNumber(clock, time) {\n    if (isNumber(time)) {\n        // no need to change anything - we want to store numbers anyway\n        // we assume this is nanosecond precision\n        return time;\n    }\n    if (time instanceof Date) {\n        return clock.convert(time);\n    }\n    return clock.now();\n}\n\nexport { timeToNumber };\n","import { SpanAttributes } from './attributes.js';\nimport { SpanInternal, coreSpanOptionSchema } from './span.js';\nimport { timeToNumber } from './time.js';\nimport { isSpanContext, isObject } from './validation.js';\n\nconst DISCARD_END_TIME = -1;\nclass SpanFactory {\n    constructor(processor, sampler, idGenerator, spanAttributesSource, clock, backgroundingListener, logger, spanContextStorage) {\n        this.openSpans = new WeakSet();\n        this.isInForeground = true;\n        this.onBackgroundStateChange = (state) => {\n            this.isInForeground = state === 'in-foreground';\n            // clear all open spans regardless of the new background state\n            // since spans are only valid if they start and end while the app is in the foreground\n            this.openSpans = new WeakSet();\n        };\n        this.processor = processor;\n        this.sampler = sampler;\n        this.idGenerator = idGenerator;\n        this.spanAttributesSource = spanAttributesSource;\n        this.clock = clock;\n        this.logger = logger;\n        this.spanContextStorage = spanContextStorage;\n        // this will fire immediately if the app is already backgrounded\n        backgroundingListener.onStateChange(this.onBackgroundStateChange);\n    }\n    startSpan(name, options) {\n        const safeStartTime = timeToNumber(this.clock, options.startTime);\n        const spanId = this.idGenerator.generate(64);\n        // if the parentContext option is not set use the current context\n        // if parentContext is explicitly null, or there is no current context,\n        // we are starting a new root span\n        const parentContext = isSpanContext(options.parentContext) || options.parentContext === null\n            ? options.parentContext\n            : this.spanContextStorage.current;\n        const parentSpanId = parentContext ? parentContext.id : undefined;\n        const traceId = parentContext ? parentContext.traceId : this.idGenerator.generate(128);\n        const attributes = new SpanAttributes(new Map());\n        if (typeof options.isFirstClass === 'boolean') {\n            attributes.set('bugsnag.span.first_class', options.isFirstClass);\n        }\n        const span = new SpanInternal(spanId, traceId, name, safeStartTime, attributes, parentSpanId);\n        // don't track spans that are started while the app is backgrounded\n        if (this.isInForeground) {\n            this.openSpans.add(span);\n            if (options.makeCurrentContext !== false) {\n                this.spanContextStorage.push(span);\n            }\n        }\n        return span;\n    }\n    configure(processor, logger) {\n        this.processor = processor;\n        this.logger = logger;\n    }\n    endSpan(span, endTime) {\n        // if the span doesn't exist here it shouldn't be processed\n        if (!this.openSpans.delete(span)) {\n            // only warn if the span has already been ended explicitly rather than\n            // discarded by us\n            if (!span.isValid()) {\n                this.logger.warn('Attempted to end a Span which has already ended.');\n            }\n            return;\n        }\n        // Discard marked spans\n        if (endTime === DISCARD_END_TIME)\n            return;\n        this.spanAttributesSource.requestAttributes(span);\n        const spanEnded = span.end(endTime, this.sampler.spanProbability);\n        this.spanContextStorage.pop(span);\n        if (this.sampler.sample(spanEnded)) {\n            this.processor.add(spanEnded);\n        }\n    }\n    toPublicApi(span) {\n        return {\n            get id() {\n                return span.id;\n            },\n            get traceId() {\n                return span.traceId;\n            },\n            isValid: () => span.isValid(),\n            end: (endTime) => {\n                const safeEndTime = timeToNumber(this.clock, endTime);\n                this.endSpan(span, safeEndTime);\n            }\n        };\n    }\n    validateSpanOptions(name, options, schema = coreSpanOptionSchema) {\n        let warnings = '';\n        const cleanOptions = {};\n        if (typeof name !== 'string') {\n            warnings += `\\n  - name should be a string, got ${typeof name}`;\n            name = String(name);\n        }\n        if (options !== undefined && !isObject(options)) {\n            warnings += '\\n  - options is not an object';\n        }\n        else {\n            const spanOptions = options || {};\n            for (const option of Object.keys(schema)) {\n                if (Object.prototype.hasOwnProperty.call(spanOptions, option) && spanOptions[option] !== undefined) {\n                    if (schema[option].validate(spanOptions[option])) {\n                        cleanOptions[option] = spanOptions[option];\n                    }\n                    else {\n                        warnings += `\\n  - ${option} ${schema[option].message}, got ${typeof spanOptions[option]}`;\n                        cleanOptions[option] = schema[option].getDefaultValue(spanOptions[option]);\n                    }\n                }\n                else {\n                    cleanOptions[option] = schema[option].getDefaultValue(spanOptions[option]);\n                }\n            }\n        }\n        if (warnings.length > 0) {\n            this.logger.warn(`Invalid span options${warnings}`);\n        }\n        return { name, options: cleanOptions };\n    }\n}\n\nexport { DISCARD_END_TIME, SpanFactory };\n","import { isDeviceId, isPersistedProbability } from './validation.js';\n\nclass InMemoryPersistence {\n    constructor() {\n        this.persistedItems = new Map();\n    }\n    async load(key) {\n        return this.persistedItems.get(key);\n    }\n    async save(key, value) {\n        this.persistedItems.set(key, value);\n    }\n}\nfunction toPersistedPayload(key, raw) {\n    switch (key) {\n        case 'bugsnag-sampling-probability': {\n            const json = JSON.parse(raw);\n            return isPersistedProbability(json)\n                ? json\n                : undefined;\n        }\n        case 'bugsnag-anonymous-id':\n            return isDeviceId(raw)\n                ? raw\n                : undefined;\n    }\n}\n\nexport { InMemoryPersistence, toPersistedPayload };\n","const msInDay = 24 * 60 * 60000;\nclass InMemoryQueue {\n    constructor(delivery, retryQueueMaxSize) {\n        this.delivery = delivery;\n        this.retryQueueMaxSize = retryQueueMaxSize;\n        this.requestQueue = Promise.resolve();\n        this.payloads = [];\n    }\n    add(payload, time) {\n        this.payloads.push({ payload, time });\n        let spanCount = this.payloads.reduce((count, { payload }) => count + countSpansInPayload(payload), 0);\n        while (spanCount > this.retryQueueMaxSize) {\n            const payload = this.payloads.shift();\n            if (!payload) {\n                break;\n            }\n            spanCount -= countSpansInPayload(payload.payload);\n        }\n    }\n    async flush() {\n        if (this.payloads.length === 0)\n            return;\n        const payloads = this.payloads;\n        this.payloads = [];\n        this.requestQueue = this.requestQueue.then(async () => {\n            for (const { payload, time } of payloads) {\n                // discard payloads at least 24 hours old\n                if (Date.now() >= time + msInDay)\n                    continue;\n                try {\n                    const { state } = await this.delivery.send(payload);\n                    switch (state) {\n                        case 'success':\n                        case 'failure-discard':\n                            break;\n                        case 'failure-retryable':\n                            this.add(payload, time);\n                            break;\n                        default:\n                            state;\n                    }\n                }\n                catch (err) { }\n            }\n        });\n        await this.requestQueue;\n    }\n}\nfunction countSpansInPayload(payload) {\n    let count = 0;\n    for (let i = 0; i < payload.body.resourceSpans.length; ++i) {\n        const scopeSpans = payload.body.resourceSpans[i].scopeSpans;\n        for (let j = 0; j < scopeSpans.length; ++j) {\n            count += scopeSpans[j].spans.length;\n        }\n    }\n    return count;\n}\n\nexport { InMemoryQueue };\n","import { responseStateFromStatusCode } from '@bugsnag/core-performance';\n\nfunction samplingProbabilityFromHeaders(headers) {\n    const value = headers.get('Bugsnag-Sampling-Probability');\n    if (typeof value !== 'string') {\n        return undefined;\n    }\n    const asNumber = Number.parseFloat(value);\n    if (Number.isNaN(asNumber) || asNumber < 0 || asNumber > 1) {\n        return undefined;\n    }\n    return asNumber;\n}\nfunction createFetchDeliveryFactory(fetch, clock, backgroundingListener) {\n    // if a backgrounding listener is supplied, set fetch's 'keepalive' flag\n    // when the app is backgrounded/terminated so that we can flush the last batch\n    // this may be required on platforms such as browser where without 'keepalive'\n    // the request may be cancelled (or never start sending) when backgrounded\n    // we don't _always_ set the flag because it imposes a 64k payload limit\n    let keepalive = false;\n    if (backgroundingListener) {\n        backgroundingListener.onStateChange(state => {\n            keepalive = state === 'in-background';\n        });\n    }\n    return function fetchDeliveryFactory(endpoint) {\n        return {\n            async send(payload) {\n                const body = JSON.stringify(payload.body);\n                payload.headers['Bugsnag-Sent-At'] = clock.date().toISOString();\n                try {\n                    const response = await fetch(endpoint, {\n                        method: 'POST',\n                        keepalive,\n                        body,\n                        headers: payload.headers\n                    });\n                    return {\n                        state: responseStateFromStatusCode(response.status),\n                        samplingProbability: samplingProbabilityFromHeaders(response.headers)\n                    };\n                }\n                catch (err) {\n                    if (body.length > 10e5) {\n                        return { state: 'failure-discard' };\n                    }\n                    return { state: 'failure-retryable' };\n                }\n            }\n        };\n    };\n}\n\nexport { createFetchDeliveryFactory as default };\n","function defaultNetworkRequestCallback(networkRequestInfo) {\n    return networkRequestInfo;\n}\nfunction isNetworkRequestCallback(value) {\n    return typeof value === 'function';\n}\n\nexport { defaultNetworkRequestCallback, isNetworkRequestCallback };\n","class RequestTracker {\n    constructor() {\n        this.callbacks = [];\n    }\n    onStart(startCallback) {\n        this.callbacks.push(startCallback);\n    }\n    start(context) {\n        const endCallbacks = [];\n        for (const startCallback of this.callbacks) {\n            const endCallback = startCallback(context);\n            if (endCallback)\n                endCallbacks.push(endCallback);\n        }\n        return (endContext) => {\n            for (const endCallback of endCallbacks) {\n                endCallback(endContext);\n            }\n        };\n    }\n}\n\nexport { RequestTracker };\n","function getAbsoluteUrl(url, baseUrl) {\n    // if it looks like an absolute url do nothing\n    if (url.indexOf('https://') === 0 || url.indexOf('http://') === 0)\n        return url;\n    try {\n        const absoluteUrl = new URL(url, baseUrl).href;\n        // if a trailing slash has been added inadvertently remove it\n        if (!url.endsWith('/') && absoluteUrl.endsWith('/')) {\n            return absoluteUrl.slice(0, -1);\n        }\n        return absoluteUrl;\n    }\n    catch (_a) {\n        // not a valid URL for some reason - simply return it\n        return url;\n    }\n}\n\nexport { getAbsoluteUrl as default };\n","import { RequestTracker } from './request-tracker.js';\nimport getAbsoluteUrl from './url-helpers.js';\n\nfunction createStartContext(startTime, input, init, baseUrl) {\n    const inputIsRequest = isRequest(input);\n    const url = inputIsRequest ? input.url : String(input);\n    const method = (!!init && init.method) || (inputIsRequest && input.method) || 'GET';\n    return { url: getAbsoluteUrl(url, baseUrl), method, startTime, type: 'fetch' };\n}\nfunction isRequest(input) {\n    return !!input && typeof input === 'object' && !(input instanceof URL);\n}\nfunction createFetchRequestTracker(global, clock) {\n    const requestTracker = new RequestTracker();\n    const originalFetch = global.fetch;\n    global.fetch = function fetch(input, init) {\n        const startContext = createStartContext(clock.now(), input, init, global.document && global.document.baseURI);\n        const onRequestEnd = requestTracker.start(startContext);\n        return originalFetch.call(this, input, init).then(response => {\n            onRequestEnd({ status: response.status, endTime: clock.now(), state: 'success' });\n            return response;\n        }).catch(error => {\n            onRequestEnd({ error, endTime: clock.now(), state: 'error' });\n            throw error;\n        });\n    };\n    return requestTracker;\n}\n\nexport { createFetchRequestTracker as default };\n","import { isObject } from '@bugsnag/core-performance'\n\nexport interface SendPageAttributes {\n  referrer?: boolean\n  title?: boolean\n  url?: boolean\n}\n\nexport const defaultSendPageAttributes = {\n  referrer: true,\n  title: true,\n  url: true\n}\n\nexport function getPermittedAttributes (sendPageAttributes: SendPageAttributes) {\n  return {\n    ...defaultSendPageAttributes,\n    ...sendPageAttributes\n  }\n}\n\nexport function isSendPageAttributes (obj: unknown): obj is SendPageAttributes {\n  const allowedTypes = ['undefined', 'boolean']\n  const keys = Object.keys(defaultSendPageAttributes)\n\n  return isObject(obj) && keys.every(key => allowedTypes.includes(typeof obj[key]))\n}\n","import type { SpanContext, SpanFactory } from '@bugsnag/core-performance'\nimport { type BrowserConfiguration } from '../config'\nimport { type PerformanceWithTiming } from '../on-settle/load-event-end-settler'\n\ntype PageLoadPhase = 'Unload'\n| 'Redirect'\n| 'LoadFromCache'\n| 'DNSLookup'\n| 'TCPHandshake'\n| 'TLS'\n| 'HTTPRequest'\n| 'HTTPResponse'\n| 'DomContentLoadedEvent'\n| 'LoadEvent'\n\nfunction shouldOmitSpan (startTime?: number, endTime?: number): boolean {\n  return (startTime === undefined || endTime === undefined) ||\n  (startTime === 0 && endTime === 0)\n}\n\nexport const instrumentPageLoadPhaseSpans = (\n  spanFactory: SpanFactory<BrowserConfiguration>,\n  performance: PerformanceWithTiming,\n  route: string,\n  parentContext: SpanContext\n) => {\n  function createPageLoadPhaseSpan (phase: PageLoadPhase, startTime: number, endTime: number) {\n    if (shouldOmitSpan(startTime, endTime)) return\n    const span = spanFactory.startSpan(`[PageLoadPhase/${phase}]${route}`, {\n      startTime,\n      parentContext,\n      makeCurrentContext: false\n    })\n\n    span.setAttribute('bugsnag.span.category', 'page_load_phase')\n    span.setAttribute('bugsnag.phase', phase)\n    spanFactory.endSpan(span, endTime)\n  }\n\n  const entries = performance.getEntriesByType('navigation') as PerformanceNavigationTiming[]\n  const entry = Array.isArray(entries) && entries[0]\n\n  if (entry) {\n    createPageLoadPhaseSpan('Unload', entry.unloadEventStart, entry.unloadEventEnd)\n    createPageLoadPhaseSpan('Redirect', entry.redirectStart, entry.redirectEnd)\n    createPageLoadPhaseSpan('LoadFromCache', entry.fetchStart, entry.domainLookupStart)\n    createPageLoadPhaseSpan('DNSLookup', entry.domainLookupStart, entry.domainLookupEnd)\n\n    // secureConectionStart will be 0 if no secure connection is used so use connectEnd in that case\n    const TCPHandshakeEnd = entry.secureConnectionStart || entry.connectEnd\n    createPageLoadPhaseSpan('TCPHandshake', entry.connectStart, TCPHandshakeEnd)\n\n    createPageLoadPhaseSpan('TLS', entry.secureConnectionStart, entry.connectEnd)\n    createPageLoadPhaseSpan('HTTPRequest', entry.requestStart, entry.responseStart)\n    createPageLoadPhaseSpan('HTTPResponse', entry.responseStart, entry.responseEnd)\n    createPageLoadPhaseSpan('DomContentLoadedEvent', entry.domContentLoadedEventStart, entry.domContentLoadedEventEnd)\n    createPageLoadPhaseSpan('LoadEvent', entry.loadEventStart, entry.loadEventEnd)\n  }\n}\n","import { type OnSettle } from './on-settle'\nimport { getAbsoluteUrl } from '@bugsnag/request-tracker-performance'\nimport { type RouteResolver, type RoutingProvider, type StartRouteChangeCallback } from './routing-provider'\n\nexport const defaultRouteResolver: RouteResolver = (url: URL) => url.pathname || '/'\n\nexport const createNoopRoutingProvider = () => {\n  return class NoopRoutingProvider implements RoutingProvider {\n    resolveRoute: RouteResolver\n\n    constructor (resolveRoute = defaultRouteResolver) {\n      this.resolveRoute = resolveRoute\n    }\n\n    listenForRouteChanges (startRouteChangeSpan: StartRouteChangeCallback) {}\n  }\n}\n\nexport const createDefaultRoutingProvider = (onSettle: OnSettle, location: Location) => {\n  return class DefaultRoutingProvider implements RoutingProvider {\n    resolveRoute: RouteResolver\n\n    constructor (resolveRoute = defaultRouteResolver) {\n      this.resolveRoute = resolveRoute\n    }\n\n    listenForRouteChanges (startRouteChangeSpan: StartRouteChangeCallback) {\n      addEventListener('popstate', (ev) => {\n        const url = new URL(location.href)\n        const span = startRouteChangeSpan(url, 'popstate')\n\n        onSettle((endTime) => {\n          span.end(endTime)\n        })\n      })\n\n      const originalPushState = history.pushState\n      history.pushState = function (...args) {\n        const url = args[2]\n\n        if (url) {\n          const absoluteURL = new URL(getAbsoluteUrl(url.toString(), document.baseURI))\n          const span = startRouteChangeSpan(absoluteURL, 'pushState')\n\n          onSettle((endTime) => {\n            span.end(endTime)\n          })\n        }\n\n        originalPushState.apply(this, args)\n      }\n    }\n  }\n}\n","import {\n  type BackgroundingListener,\n  type InternalConfiguration,\n  type Plugin,\n  type SpanFactory\n} from '@bugsnag/core-performance'\nimport { type BrowserConfiguration } from '../config'\nimport { type OnSettle } from '../on-settle'\nimport { type PerformanceWithTiming } from '../on-settle/load-event-end-settler'\nimport { getPermittedAttributes } from '../send-page-attributes'\nimport { type WebVitals } from '../web-vitals'\nimport { instrumentPageLoadPhaseSpans } from './page-load-phase-spans'\nimport { defaultRouteResolver } from '../default-routing-provider'\n\nexport class FullPageLoadPlugin implements Plugin<BrowserConfiguration> {\n  private readonly spanFactory: SpanFactory<BrowserConfiguration>\n  private readonly document: Document\n  private readonly location: Location\n  private readonly onSettle: OnSettle\n  private readonly webVitals: WebVitals\n  private readonly performance: PerformanceWithTiming\n\n  // if the page was backgrounded at any point in the loading process a page\n  // load span is invalidated as the browser will deprioritise the page\n  private wasBackgrounded: boolean = false\n\n  constructor (\n    document: Document,\n    location: Location,\n    spanFactory: SpanFactory<BrowserConfiguration>,\n    webVitals: WebVitals,\n    onSettle: OnSettle,\n    backgroundingListener: BackgroundingListener,\n    performance: PerformanceWithTiming\n  ) {\n    this.document = document\n    this.location = location\n    this.spanFactory = spanFactory\n    this.webVitals = webVitals\n    this.onSettle = onSettle\n    this.performance = performance\n\n    backgroundingListener.onStateChange(state => {\n      if (!this.wasBackgrounded && state === 'in-background') {\n        this.wasBackgrounded = true\n      }\n    })\n  }\n\n  configure (configuration: InternalConfiguration<BrowserConfiguration>) {\n    // don't report a page load span if the option is turned off or the page was\n    // backgrounded at any point in the loading process\n    if (!configuration.autoInstrumentFullPageLoads || this.wasBackgrounded) {\n      return\n    }\n\n    const span = this.spanFactory.startSpan('[FullPageLoad]', { startTime: 0, parentContext: null })\n    const permittedAttributes = getPermittedAttributes(configuration.sendPageAttributes)\n    const url = new URL(this.location.href)\n\n    this.onSettle((endTime: number) => {\n      if (this.wasBackgrounded) return\n\n      // ensure there's always a route on this span by falling back to the\n      // default route resolver - the pipeline will ignore page load spans that\n      // don't have a route\n      const route = configuration.routingProvider.resolveRoute(url) || defaultRouteResolver(url)\n      span.name += route\n\n      instrumentPageLoadPhaseSpans(this.spanFactory, this.performance, route, span)\n\n      // Browser attributes\n      span.setAttribute('bugsnag.span.category', 'full_page_load')\n      span.setAttribute('bugsnag.browser.page.route', route)\n      if (permittedAttributes.referrer) span.setAttribute('bugsnag.browser.page.referrer', this.document.referrer)\n      if (permittedAttributes.title) span.setAttribute('bugsnag.browser.page.title', this.document.title)\n      if (permittedAttributes.url) span.setAttribute('bugsnag.browser.page.url', url.toString())\n\n      this.webVitals.attachTo(span)\n      this.spanFactory.endSpan(span, endTime)\n    })\n  }\n}\n","import { type InternalConfiguration, type Logger, type Plugin, type SpanFactory } from '@bugsnag/core-performance'\nimport {\n  defaultNetworkRequestCallback,\n  type NetworkRequestCallback,\n  type NetworkRequestInfo,\n  type RequestEndCallback,\n  type RequestEndContext,\n  type RequestStartContext,\n  type RequestTracker\n} from '@bugsnag/request-tracker-performance'\nimport { type BrowserConfiguration } from '../config'\n\nexport interface BrowserNetworkRequestInfo extends NetworkRequestInfo {\n  readonly type: PerformanceResourceTiming['initiatorType']\n}\n\nconst permittedPrefixes = ['http://', 'https://', '/', './', '../']\n\nexport class NetworkRequestPlugin implements Plugin<BrowserConfiguration> {\n  private configEndpoint: string = ''\n  private networkRequestCallback: NetworkRequestCallback<BrowserNetworkRequestInfo> = defaultNetworkRequestCallback\n  private logger: Logger = { debug: console.debug, warn: console.warn, info: console.info, error: console.error }\n\n  constructor (\n    private spanFactory: SpanFactory<BrowserConfiguration>,\n    private fetchTracker: RequestTracker,\n    private xhrTracker: RequestTracker\n  ) {}\n\n  configure (configuration: InternalConfiguration<BrowserConfiguration>) {\n    this.logger = configuration.logger\n\n    if (configuration.autoInstrumentNetworkRequests) {\n      this.configEndpoint = configuration.endpoint\n      this.xhrTracker.onStart(this.trackRequest)\n      this.fetchTracker.onStart(this.trackRequest)\n      this.networkRequestCallback = configuration.networkRequestCallback\n    }\n  }\n\n  private trackRequest = (startContext: RequestStartContext): RequestEndCallback | undefined => {\n    if (!this.shouldTrackRequest(startContext)) return\n\n    const networkRequestInfo = this.networkRequestCallback({ url: startContext.url, type: startContext.type })\n\n    if (!networkRequestInfo) return\n\n    if (typeof networkRequestInfo.url !== 'string') {\n      this.logger.warn(`expected url to be a string following network request callback, got ${typeof networkRequestInfo.url}`)\n      return\n    }\n\n    const span = this.spanFactory.startSpan(\n      `[HTTP]/${startContext.method.toUpperCase()}`,\n      { startTime: startContext.startTime, makeCurrentContext: false }\n    )\n\n    span.setAttribute('bugsnag.span.category', 'network')\n    span.setAttribute('http.method', startContext.method)\n    span.setAttribute('http.url', networkRequestInfo.url)\n\n    return (endContext: RequestEndContext) => {\n      if (endContext.state === 'success') {\n        span.setAttribute('http.status_code', endContext.status)\n        this.spanFactory.endSpan(span, endContext.endTime)\n      }\n    }\n  }\n\n  private shouldTrackRequest (startContext: RequestStartContext): boolean {\n    return startContext.url !== this.configEndpoint && permittedPrefixes.some((prefix) => startContext.url.startsWith(prefix))\n  }\n}\n","import { type SpanContextStorage, type InternalConfiguration, type Plugin, type SpanFactory } from '@bugsnag/core-performance'\nimport { type BrowserConfiguration } from '../config'\n\ninterface ResourceTiming extends PerformanceResourceTiming {\n  responseStatus?: number // https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/responseStatus\n}\n\nexport function getHttpVersion (protocol: string) {\n  switch (protocol) {\n    case '':\n      return undefined\n    case 'http/1.0':\n      return '1.0'\n    case 'http/1.1':\n      return '1.1'\n    case 'h2':\n    case 'h2c':\n      return '2.0'\n    case 'h3':\n      return '3.0'\n    case 'spdy/1':\n    case 'spdy/2':\n    case 'spdy/3':\n      return 'SPDY'\n    default:\n      return protocol\n  }\n}\n\nfunction resourceLoadSupported (PerformanceObserverClass: typeof PerformanceObserver) {\n  return PerformanceObserverClass &&\n    Array.isArray(PerformanceObserverClass.supportedEntryTypes) &&\n    PerformanceObserverClass.supportedEntryTypes.includes('resource')\n}\n\nexport class ResourceLoadPlugin implements Plugin<BrowserConfiguration> {\n  constructor (\n    private readonly spanFactory: SpanFactory<BrowserConfiguration>,\n    private readonly spanContextStorage: SpanContextStorage,\n    private readonly PerformanceObserverClass: typeof PerformanceObserver\n  ) {}\n\n  configure (configuration: InternalConfiguration<BrowserConfiguration>) {\n    if (!resourceLoadSupported(this.PerformanceObserverClass)) return\n\n    const observer = new this.PerformanceObserverClass((list) => {\n      const entries = list.getEntries() as ResourceTiming[]\n\n      for (const entry of entries) {\n        if (entry.initiatorType === 'fetch' || entry.initiatorType === 'xmlhttprequest') {\n          continue\n        }\n\n        const parentContext = this.spanContextStorage.first\n\n        if (parentContext) {\n          const networkRequestInfo = configuration.networkRequestCallback({ url: entry.name, type: entry.initiatorType })\n\n          if (!networkRequestInfo) return\n\n          if (typeof networkRequestInfo.url !== 'string') {\n            configuration.logger.warn(`expected url to be a string following network request callback, got ${typeof networkRequestInfo.url}`)\n            return\n          }\n\n          let name = ''\n          try {\n            const url = new URL(networkRequestInfo.url)\n            url.search = ''\n            name = url.href\n          } catch (err) {\n            configuration.logger.warn(`Unable to parse URL returned from networkRequestCallback: ${networkRequestInfo.url}`)\n            return\n          }\n\n          const span = this.spanFactory.startSpan(`[ResourceLoad]${name}`, {\n            parentContext,\n            startTime: entry.startTime,\n            makeCurrentContext: false\n          })\n\n          span.setAttribute('bugsnag.span.category', 'resource_load')\n          span.setAttribute('http.url', networkRequestInfo.url)\n\n          const httpFlavor = getHttpVersion(entry.nextHopProtocol)\n          if (httpFlavor) {\n            span.setAttribute('http.flavor', httpFlavor)\n          }\n\n          if (entry.encodedBodySize && entry.decodedBodySize) {\n            span.setAttribute('http.response_content_length', entry.encodedBodySize)\n            span.setAttribute('http.response_content_length_uncompressed', entry.decodedBodySize)\n          }\n\n          if (entry.responseStatus) {\n            span.setAttribute('http.status_code', entry.responseStatus)\n          }\n\n          this.spanFactory.endSpan(span, entry.responseEnd)\n        }\n      }\n    })\n\n    try {\n      observer.observe({ type: 'resource', buffered: true })\n    } catch (err) {\n      configuration.logger.warn('Unable to get previous resource loads as buffered observer not supported, only showing resource loads from this point on')\n      observer.observe({ entryTypes: ['resource'] })\n    }\n  }\n}\n","import { coreSpanOptionSchema, isString, type InternalConfiguration, type Plugin, type SpanFactory, type SpanOptionSchema, type Time, isObject } from '@bugsnag/core-performance'\nimport { type BrowserConfiguration } from '../config'\nimport { type RouteChangeSpanEndOptions, type RouteChangeSpanOptions } from '../routing-provider'\nimport { getPermittedAttributes } from '../send-page-attributes'\nimport { defaultRouteResolver } from '../default-routing-provider'\n\n// exclude isFirstClass from the route change option schema\nconst { startTime, parentContext, makeCurrentContext } = coreSpanOptionSchema\nconst routeChangeSpanOptionSchema: SpanOptionSchema = {\n  startTime,\n  parentContext,\n  makeCurrentContext,\n  trigger: {\n    getDefaultValue: (value) => String(value),\n    message: 'should be a string',\n    validate: isString\n  }\n}\n\ninterface InternalRouteChangeSpanOptions extends RouteChangeSpanOptions {\n  url: URL\n  trigger: string\n}\n\nexport class RouteChangePlugin implements Plugin<BrowserConfiguration> {\n  constructor (\n    private readonly spanFactory: SpanFactory<BrowserConfiguration>,\n    private readonly location: Location,\n    private readonly document: Document\n  ) {}\n\n  configure (configuration: InternalConfiguration<BrowserConfiguration>) {\n    if (!configuration.autoInstrumentRouteChanges) return\n\n    const previousUrl = new URL(this.location.href)\n    let previousRoute = configuration.routingProvider.resolveRoute(previousUrl) || defaultRouteResolver(previousUrl)\n\n    const permittedAttributes = getPermittedAttributes(configuration.sendPageAttributes)\n\n    configuration.routingProvider.listenForRouteChanges((url, trigger, options) => {\n      let absoluteUrl\n\n      if (url instanceof URL) {\n        absoluteUrl = url\n      } else {\n        try {\n          const stringUrl = String(url)\n          absoluteUrl = new URL(stringUrl)\n        } catch (err) {\n          configuration.logger.warn('Invalid span options\\n  - url should be a URL')\n\n          return {\n            id: '',\n            traceId: '',\n            isValid: () => false,\n            end: () => {}\n          }\n        }\n      }\n\n      // create internal options for validation\n      const routeChangeSpanOptions = {\n        ...options,\n        trigger\n      }\n\n      const cleanOptions = this.spanFactory.validateSpanOptions<InternalRouteChangeSpanOptions>(\n        '[RouteChange]',\n        routeChangeSpanOptions,\n        routeChangeSpanOptionSchema\n      )\n\n      const route = configuration.routingProvider.resolveRoute(absoluteUrl) || defaultRouteResolver(absoluteUrl)\n\n      // update the span name using the validated route\n      cleanOptions.name += route\n      const span = this.spanFactory.startSpan(cleanOptions.name, cleanOptions.options)\n\n      span.setAttribute('bugsnag.span.category', 'route_change')\n      span.setAttribute('bugsnag.browser.page.route', route)\n      span.setAttribute('bugsnag.browser.page.previous_route', previousRoute)\n      span.setAttribute('bugsnag.browser.page.route_change.trigger', cleanOptions.options.trigger)\n      if (permittedAttributes.url) span.setAttribute('bugsnag.browser.page.url', url.toString())\n\n      previousRoute = route\n\n      return {\n        id: span.id,\n        traceId: span.traceId,\n        isValid: span.isValid,\n        end: (endTimeOrOptions?: Time | RouteChangeSpanEndOptions): void => {\n          const options: RouteChangeSpanEndOptions = isObject(endTimeOrOptions) ? endTimeOrOptions : { endTime: endTimeOrOptions }\n\n          if (permittedAttributes.title) {\n            span.setAttribute('bugsnag.browser.page.title', this.document.title)\n          }\n\n          if (options.url) {\n            const urlObject = ensureUrl(options.url) // convert strings to URL if necessary\n            const route = configuration.routingProvider.resolveRoute(urlObject) || defaultRouteResolver(urlObject)\n\n            span.name = `[RouteChange]${route}`\n            span.setAttribute('bugsnag.browser.page.route', route)\n            previousRoute = route\n\n            // update the URL attribute as well\n            if (permittedAttributes.url) {\n              span.setAttribute('bugsnag.browser.page.url', urlObject.toString())\n            }\n          }\n\n          this.spanFactory.toPublicApi(span).end(options.endTime)\n        }\n\n      }\n    })\n  }\n}\n\nfunction ensureUrl (url: string | URL): URL {\n  if (typeof url === 'string') {\n    return new URL(url)\n  }\n  return url\n}\n","import { type BackgroundingListener, type Clock, millisecondsToNanoseconds } from '@bugsnag/core-performance'\n\n// a cut-down PerformanceTiming interface, since we don't care about most of\n// its properties\ninterface PerformanceTiming {\n  navigationStart: number\n}\n\n// the 'Performance' type says 'timeOrigin' is always available, but that's not\n// true on Safari <15 so we mark it as possibly 'undefined'\ninterface PerformanceWithOptionalTimeOrigin {\n  now: () => number\n  timeOrigin?: number\n  timing: PerformanceTiming\n}\n\n// maximum allowed clock divergence in milliseconds\nconst MAX_CLOCK_DRIFT_MS = 300000\n\nfunction recalculateTimeOrigin (timeOrigin: number, performance: PerformanceWithOptionalTimeOrigin): number {\n  // if the machine has been sleeping the monatomic clock used by performance.now() may have been paused,\n  // so we need to check if this has drifted significantly from Date.now()\n  // if the drift is > 5 minutes re-set the clock's origin to bring it back in line with Date.now()\n  if (Math.abs(Date.now() - (timeOrigin + performance.now())) > MAX_CLOCK_DRIFT_MS) {\n    return Date.now() - performance.now()\n  }\n\n  return timeOrigin\n}\n\nfunction createClock (performance: PerformanceWithOptionalTimeOrigin, backgroundingListener: BackgroundingListener): Clock {\n  const initialTimeOrigin = performance.timeOrigin === undefined\n    ? performance.timing.navigationStart\n    : performance.timeOrigin\n\n  // the performance clock could be shared between different tabs running in the same process\n  // so may already have diverged - for this reason we calculate a time origin when we first create the clock\n  // as well as when the app returns to the foreground\n  let calculatedTimeOrigin = recalculateTimeOrigin(initialTimeOrigin, performance)\n  backgroundingListener.onStateChange(state => {\n    if (state === 'in-foreground') {\n      calculatedTimeOrigin = recalculateTimeOrigin(calculatedTimeOrigin, performance)\n    }\n  })\n\n  return {\n    now: () => performance.now(),\n    date: () => new Date(calculatedTimeOrigin + performance.now()),\n    convert: (date) => date.getTime() - calculatedTimeOrigin,\n    // convert milliseconds since timeOrigin to full timestamp\n    toUnixTimestampNanoseconds: (time: number) => millisecondsToNanoseconds(calculatedTimeOrigin + time).toString()\n  }\n}\n\nexport default createClock\n","import { isObject, type Time, type Span, type SpanOptions } from '@bugsnag/core-performance'\n\nexport type RouteChangeSpanOptions = Omit<SpanOptions, 'isFirstClass'>\nexport type StartRouteChangeCallback = (url: URL | string, trigger: string, options?: RouteChangeSpanOptions) => RouteChangeSpan\n\nexport interface RouteChangeSpanEndOptions {\n  endTime?: number | Date\n  url?: URL | string\n}\n\nexport interface RouteChangeSpan extends Span {\n  end: ((endTime?: Time) => void) & ((routeChangeSpanEndOptions: RouteChangeSpanEndOptions) => void)\n}\n\nexport interface RoutingProvider {\n  resolveRoute: (url: URL) => string\n  listenForRouteChanges: (startRouteChangeSpan: StartRouteChangeCallback) => void\n}\n\nexport type RouteResolver = (url: URL) => string\n\nexport const isRoutingProvider = (value: unknown): value is RoutingProvider =>\n  isObject(value) &&\n    typeof value.resolveRoute === 'function' &&\n    typeof value.listenForRouteChanges === 'function'\n","import type { BitLength, IdGenerator } from '@bugsnag/core-performance'\n\nfunction toHex (value: number): string {\n  const hex = value.toString(16)\n\n  // pad hex with a leading 0 if it's not already 2 characters\n  if (hex.length === 1) {\n    return '0' + hex\n  }\n\n  return hex\n}\n\nconst idGenerator: IdGenerator = {\n  generate (bits: BitLength): string {\n    const bytes = new Uint8Array(bits / 8)\n\n    // TODO: do we just read window here?\n    //       how can we pass this in given it needs to be valid before 'start' is called?\n    const randomValues = window.crypto.getRandomValues(bytes)\n\n    return Array.from(randomValues, toHex).join('')\n  }\n}\n\nexport default idGenerator\n","import { type Clock } from '@bugsnag/core-performance'\nimport { type OnSettleCallback } from '.'\n\nexport abstract class Settler {\n  protected clock: Clock\n  protected settled: boolean = false\n\n  private readonly callbacks: Set<OnSettleCallback> = new Set<OnSettleCallback>()\n\n  constructor (clock: Clock) {\n    this.clock = clock\n  }\n\n  subscribe (callback: OnSettleCallback): void {\n    this.callbacks.add(callback)\n\n    // if we're already settled, call the callback immediately\n    if (this.isSettled()) {\n      callback(this.clock.now())\n    }\n  }\n\n  unsubscribe (callback: OnSettleCallback): void {\n    this.callbacks.delete(callback)\n  }\n\n  isSettled (): boolean {\n    return this.settled\n  }\n\n  protected settle (settledTime: number): void {\n    this.settled = true\n\n    for (const callback of this.callbacks) {\n      callback(settledTime)\n    }\n  }\n}\n","import { type Clock } from '@bugsnag/core-performance'\nimport { Settler } from './settler'\n\nclass DomMutationSettler extends Settler {\n  private timeout: ReturnType<typeof setTimeout> | undefined = undefined\n\n  constructor (clock: Clock, target: Node) {\n    super(clock)\n\n    const observer = new MutationObserver(() => { this.restart() })\n\n    observer.observe(target, {\n      subtree: true,\n      childList: true,\n      characterData: true\n      // we don't track attribute changes as they may or may not be user visible\n      // so we assume they won't affect the page appearing settled to the user\n    })\n\n    this.restart()\n  }\n\n  private restart (): void {\n    clearTimeout(this.timeout)\n    this.settled = false\n\n    // we wait 100ms to ensure that DOM mutations have actually stopped but\n    // don't want the settled time to reflect that wait, so we record the time\n    // here and use that when settling\n    const settledTime = this.clock.now()\n\n    this.timeout = setTimeout(() => { this.settle(settledTime) }, 100)\n  }\n}\n\nexport default DomMutationSettler\n","import { type Clock } from '@bugsnag/core-performance'\nimport { Settler } from './settler'\n\ntype AddEventListener = (event: string, callback: () => void) => void\n\nexport interface PerformanceWithTiming {\n  getEntriesByType: typeof performance.getEntriesByType\n  timing: {\n    loadEventEnd: number\n    navigationStart: number\n  }\n}\n\ninterface DocumentWithReadyState {\n  readyState: DocumentReadyState\n}\n\n// check if a PerformanceEntry is a PerformanceNavigationTiming\nfunction isPerformanceNavigationTiming (entry?: PerformanceEntry): entry is PerformanceNavigationTiming {\n  return !!entry && entry.entryType === 'navigation'\n}\n\nclass LoadEventEndSettler extends Settler {\n  constructor (\n    clock: Clock,\n    addEventListener: AddEventListener,\n    performance: PerformanceWithTiming,\n    document: DocumentWithReadyState\n  ) {\n    super(clock)\n\n    // we delay settling by a macrotask so that the load event has ended\n    // see: https://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context/25933985#25933985\n    //      https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n    if (document.readyState === 'complete') {\n      setTimeout(() => { this.settleUsingPerformance(performance) }, 0)\n    } else {\n      addEventListener('load', () => {\n        setTimeout(() => { this.settleUsingPerformance(performance) }, 0)\n      })\n    }\n  }\n\n  private settleUsingPerformance (performance: PerformanceWithTiming) {\n    const now = this.clock.now()\n\n    // there's only ever one navigation entry\n    // PLAT-10204 Prevent snags occuring due to DOM scanning bots like BuiltWith https://builtwith.com/biup\n    const entry = typeof performance.getEntriesByType === 'function' ? performance.getEntriesByType('navigation')[0] : undefined\n\n    let settledTime = 0\n\n    if (isPerformanceNavigationTiming(entry)) {\n      settledTime = entry.loadEventEnd\n    } else if (performance.timing) {\n      settledTime = performance.timing.loadEventEnd - performance.timing.navigationStart\n    }\n\n    // if the settled time is obviously wrong then use the current time instead\n    // this won't be a perfectly accurate value, but it should be close enough\n    // for this purpose\n    if (settledTime <= 0 || settledTime > now) {\n      settledTime = now\n    }\n\n    this.settle(settledTime)\n  }\n}\n\nexport default LoadEventEndSettler\n","import { type Clock } from '@bugsnag/core-performance'\nimport { Settler } from './settler'\nimport {\n  type RequestStartContext,\n  type RequestEndCallback,\n  type RequestEndContext,\n  type RequestTracker\n} from '@bugsnag/request-tracker-performance'\n\nclass RequestSettler extends Settler {\n  private timeout: ReturnType<typeof setTimeout> | undefined = undefined\n  private urlsToIgnore: RegExp[] = []\n  private outstandingRequests = 0\n\n  constructor (clock: Clock, requestTracker: RequestTracker) {\n    super(clock)\n\n    // unlike most other settlers we start settled as it's possible to not make\n    // any requests at all\n    // TODO: we actually should only be settled if there are no outstanding\n    //       requests when constructed\n    this.settled = true\n\n    requestTracker.onStart(this.onRequestStart.bind(this))\n  }\n\n  setUrlsToIgnore (urlsToIgnore: RegExp[]): void {\n    this.urlsToIgnore = urlsToIgnore\n  }\n\n  private onRequestStart (startContext: RequestStartContext): RequestEndCallback | undefined {\n    // if this is an excluded URL, ignore this request\n    if (this.shouldIgnoreUrl(startContext.url)) return\n\n    clearTimeout(this.timeout)\n    this.settled = false\n    ++this.outstandingRequests\n\n    return (endContext: RequestEndContext): void => {\n      if (--this.outstandingRequests === 0) {\n        // we wait 100ms to ensure that requests have actually stopped but don't\n        // want the settled time to reflect that wait, so we record the time\n        // here and use that when settling\n        const settledTime = this.clock.now()\n\n        this.timeout = setTimeout(() => { this.settle(settledTime) }, 100)\n      }\n    }\n  }\n\n  private shouldIgnoreUrl (url: string): boolean {\n    return this.urlsToIgnore.some(regexp => regexp.test(url))\n  }\n}\n\nexport default RequestSettler\n","import { type Clock } from '@bugsnag/core-performance'\nimport { Settler } from './settler'\n\n/**\n * SettlerAggregate is a Settler that is settled when ALL Settlers it is\n * constructed with are settled themselves\n */\nclass SettlerAggregate extends Settler {\n  private readonly settlers: Settler[]\n\n  constructor (clock: Clock, settlers: Settler[]) {\n    super(clock)\n    this.settlers = settlers\n\n    for (const settler of settlers) {\n      settler.subscribe((settledTime: number) => {\n        // we need to check if all of the settlers are settled here as a\n        // previously settled settler could have unsettled in the meantime\n        if (this.settlersAreSettled()) {\n          this.settle(settledTime)\n        } else {\n          this.settled = false\n        }\n      })\n    }\n  }\n\n  isSettled () {\n    // ensure all child settlers are settled as well; it's possible for all of\n    // them to have settled previously only for one to unsettle\n    return super.isSettled() && this.settlersAreSettled()\n  }\n\n  private settlersAreSettled (): boolean {\n    for (const settler of this.settlers) {\n      if (!settler.isSettled()) {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\nexport default SettlerAggregate\n","import {\n  InMemoryPersistence,\n  toPersistedPayload,\n  type Persistence,\n  type PersistenceKey,\n  type PersistencePayloadMap\n} from '@bugsnag/core-performance'\n\ninterface LocalStorage {\n  setItem: (key: string, value: string) => void\n  getItem: (key: string) => string | null\n}\n\ninterface WindowWithLocalStorage {\n  localStorage?: LocalStorage\n}\n\nfunction makeBrowserPersistence (window: WindowWithLocalStorage): Persistence {\n  // accessing localStorage can throw on some browsers, so we have to catch\n  // these errors and provide a fallback\n  try {\n    if (window.localStorage) {\n      return new BrowserPersistence(window.localStorage)\n    }\n  } catch {}\n\n  // store items in memory if localStorage isn't available\n  return new InMemoryPersistence()\n}\n\nfunction toString<K extends PersistenceKey> (key: K, value: PersistencePayloadMap[K]): string {\n  switch (key) {\n    case 'bugsnag-sampling-probability':\n      return JSON.stringify(value)\n\n    case 'bugsnag-anonymous-id':\n      return value as string\n\n    default:\n      key satisfies never\n      return key\n  }\n}\n\nclass BrowserPersistence implements Persistence {\n  private readonly storage: LocalStorage\n\n  constructor (localStorage: LocalStorage) {\n    this.storage = localStorage\n  }\n\n  async load<K extends PersistenceKey> (key: K): Promise<PersistencePayloadMap[K] | undefined> {\n    try {\n      const raw = this.storage.getItem(key)\n\n      if (raw) {\n        return toPersistedPayload(key, raw)\n      }\n    } catch {}\n  }\n\n  async save<K extends PersistenceKey> (key: K, value: PersistencePayloadMap[K]): Promise<void> {\n    try {\n      this.storage.setItem(key, toString(key, value))\n    } catch {}\n  }\n}\n\nexport default makeBrowserPersistence\n","module.exports = function pad (num, size) {\n  var s = '000000000' + num;\n  return s.substr(s.length - size);\n};\n","var pad = require('./pad.js');\n\nvar env = typeof window === 'object' ? window : self;\nvar globalCount = 0;\nfor (var prop in env) {\n  if (Object.hasOwnProperty.call(env, prop)) globalCount++;\n}\nvar mimeTypesLength = navigator.mimeTypes ? navigator.mimeTypes.length : 0;\nvar clientId = pad((mimeTypesLength +\n  navigator.userAgent.length).toString(36) +\n  globalCount.toString(36), 4);\n\nmodule.exports = function fingerprint () {\n  return clientId;\n};\n","/**\n * cuid.js\n * Collision-resistant UID generator for browsers and node.\n * Sequential for fast db lookups and recency sorting.\n * Safe for element IDs and server-side lookups.\n *\n * Extracted from CLCTR\n *\n * Copyright (c) Eric Elliott 2012\n * MIT License\n */\n\nvar fingerprint = require('./lib/fingerprint.js');\nvar pad = require('./lib/pad.js');\n\nvar c = 0,\n  blockSize = 4,\n  base = 36,\n  discreteValues = Math.pow(base, blockSize);\n\nfunction randomBlock () {\n  return pad((Math.random() *\n    discreteValues << 0)\n    .toString(base), blockSize);\n}\n\nfunction safeCounter () {\n  c = c < discreteValues ? c : 0;\n  c++; // this is not subliminal\n  return c - 1;\n}\n\nfunction cuid () {\n  // Starting with a lowercase letter makes\n  // it HTML element ID friendly.\n  var letter = 'c', // hard-coded allows for sequential access\n\n    // timestamp\n    // warning: this exposes the exact date and time\n    // that the uid was created.\n    timestamp = (new Date().getTime()).toString(base),\n\n    // Prevent same-machine collisions.\n    counter = pad(safeCounter().toString(base), blockSize),\n\n    // A few chars to generate distinct ids for different\n    // clients (so different computers are far less\n    // likely to generate the same id)\n    print = fingerprint(),\n\n    // Grab some more chars from Math.random()\n    random = randomBlock() + randomBlock();\n\n  return letter + timestamp + counter + print + random;\n}\n\ncuid.fingerprint = fingerprint;\n\nmodule.exports = cuid;\n","import { type Clock, type SpanInternal } from '@bugsnag/core-performance'\n\ninterface PerformanceWithNavigationTiming {\n  getEntriesByName: typeof performance.getEntriesByName\n  getEntriesByType: typeof performance.getEntriesByType\n  timing: {\n    responseStart: number\n    navigationStart: number\n  }\n}\n\n// layout shifts are grouped into \"session windows\", which is defined as a set\n// of layout shifts that occur with less than 1 second between each shift and a\n// maximum of 5 seconds total duration\n// see the web vitals definition:\n// https://web.dev/evolving-cls/#why-a-session-window\ninterface LayoutShiftSession {\n  value: number\n  readonly firstStartTime: number\n  previousStartTime: number\n}\n\n// https://wicg.github.io/layout-instability/#sec-layout-shift\ninterface LayoutShift extends PerformanceEntry {\n  entryType: 'layout-shift'\n  value: number\n  hadRecentInput: boolean\n  lastInputTime: number\n}\n\nexport class WebVitals {\n  private readonly performance: PerformanceWithNavigationTiming\n  private readonly clock: Clock\n  private readonly observers: PerformanceObserver[]\n\n  private largestContentfulPaint: number | undefined\n  private cumulativeLayoutShift: number | undefined\n\n  constructor (\n    performance: PerformanceWithNavigationTiming,\n    clock: Clock,\n    PerformanceObserverClass?: typeof PerformanceObserver\n  ) {\n    this.performance = performance\n    this.clock = clock\n    this.observers = []\n\n    if (PerformanceObserverClass && Array.isArray(PerformanceObserverClass.supportedEntryTypes)) {\n      const supportedEntryTypes = PerformanceObserverClass.supportedEntryTypes\n\n      if (supportedEntryTypes.includes('largest-contentful-paint')) {\n        this.observeLargestContentfulPaint(PerformanceObserverClass)\n      }\n\n      if (supportedEntryTypes.includes('layout-shift')) {\n        this.observeLayoutShift(PerformanceObserverClass)\n      }\n    }\n  }\n\n  attachTo (span: SpanInternal) {\n    const firstContentfulPaint = this.firstContentfulPaint()\n\n    if (firstContentfulPaint) {\n      span.addEvent('fcp', firstContentfulPaint)\n    }\n\n    const timeToFirstByte = this.timeToFirstByte()\n\n    if (timeToFirstByte) {\n      span.addEvent('ttfb', timeToFirstByte)\n    }\n\n    const firstInputDelay = this.firstInputDelay()\n\n    if (firstInputDelay) {\n      span.addEvent('fid_start', firstInputDelay.start)\n      span.addEvent('fid_end', firstInputDelay.end)\n    }\n\n    if (this.cumulativeLayoutShift) {\n      span.setAttribute('bugsnag.metrics.cls', this.cumulativeLayoutShift)\n    }\n\n    if (this.largestContentfulPaint) {\n      span.addEvent('lcp', this.largestContentfulPaint)\n    }\n\n    // as there is only 1 page load span, we don't need to keep observing\n    // performance events, so can disconnect from any observers we've registered\n    for (const observer of this.observers) {\n      observer.disconnect()\n    }\n  }\n\n  private firstContentfulPaint () {\n    const entries = this.performance.getEntriesByName('first-contentful-paint', 'paint')\n    const entry = Array.isArray(entries) && entries[0]\n\n    if (entry) {\n      return entry.startTime\n    }\n  }\n\n  private timeToFirstByte () {\n    const entries = this.performance.getEntriesByType('navigation') as PerformanceNavigationTiming[]\n    const entry = Array.isArray(entries) && entries[0]\n\n    let responseStart: number\n\n    if (entry) {\n      responseStart = entry.responseStart\n    } else {\n      responseStart = this.performance.timing.responseStart - this.performance.timing.navigationStart\n    }\n\n    // only use responseStart if it's valid (between 0 and the current time)\n    // any other value cannot be valid because it would mean the response\n    // started immediately or hasn't happened yet!\n    if (responseStart > 0 && responseStart <= this.clock.now()) {\n      return responseStart\n    }\n  }\n\n  private firstInputDelay () {\n    const entries = this.performance.getEntriesByType('first-input') as PerformanceEventTiming[]\n    const entry = Array.isArray(entries) && entries[0]\n\n    if (entry) {\n      return {\n        start: entry.startTime,\n        end: entry.processingStart\n      }\n    }\n  }\n\n  private observeLargestContentfulPaint (\n    PerformanceObserverClass: typeof PerformanceObserver\n  ): void {\n    const observer = new PerformanceObserverClass((list) => {\n      const entries = list.getEntries()\n\n      if (entries.length > 0) {\n        // Use the latest LCP candidate\n        this.largestContentfulPaint = entries[entries.length - 1].startTime\n      }\n    })\n\n    observer.observe({ type: 'largest-contentful-paint', buffered: true })\n\n    this.observers.push(observer)\n  }\n\n  private observeLayoutShift (\n    PerformanceObserverClass: typeof PerformanceObserver\n  ): void {\n    let session: LayoutShiftSession | undefined\n\n    const observer = new PerformanceObserverClass((list) => {\n      for (const entry of list.getEntries() as LayoutShift[]) {\n        // ignore entries with recent input as it's likely the layout shifted due\n        // to user input and this metric only cares about unexpected layout\n        // shifts\n        if (entry.hadRecentInput) {\n          continue\n        }\n\n        // include this entry in the current session if we have a current session\n        // and this entry fits into the session window (it occurred less than 1\n        // second after the previous entry and the session duration is less than\n        // 5 seconds), otherwise start a new session\n        if (\n          session &&\n          entry.startTime - session.previousStartTime < 1000 &&\n          entry.startTime - session.firstStartTime < 5000\n        ) {\n          session.value += entry.value\n          session.previousStartTime = entry.startTime\n        } else {\n          session = {\n            value: entry.value,\n            firstStartTime: entry.startTime,\n            previousStartTime: entry.startTime\n          }\n        }\n      }\n\n      if (session &&\n        (this.cumulativeLayoutShift === undefined || session.value > this.cumulativeLayoutShift)\n      ) {\n        this.cumulativeLayoutShift = session.value\n      }\n    })\n\n    observer.observe({ type: 'layout-shift', buffered: true })\n\n    this.observers.push(observer)\n  }\n}\n","import { type Client, createClient, createNoopClient, InMemoryQueue } from '@bugsnag/core-performance'\nimport createFetchDeliveryFactory from '@bugsnag/delivery-fetch-performance'\nimport { createFetchRequestTracker, createXmlHttpRequestTracker } from '@bugsnag/request-tracker-performance'\nimport { FullPageLoadPlugin, NetworkRequestPlugin, ResourceLoadPlugin, RouteChangePlugin } from './auto-instrumentation'\nimport createBrowserBackgroundingListener from './backgrounding-listener'\nimport createClock from './clock'\nimport { type BrowserConfiguration, createSchema } from './config'\nimport { createDefaultRoutingProvider, createNoopRoutingProvider } from './default-routing-provider'\nimport idGenerator from './id-generator'\nimport createOnSettle, { createNoopOnSettle, type OnSettlePlugin } from './on-settle'\nimport makeBrowserPersistence from './persistence'\nimport createResourceAttributesSource from './resource-attributes-source'\nimport createSpanAttributesSource from './span-attributes-source'\nimport { WebVitals } from './web-vitals'\n\nexport let onSettle: OnSettlePlugin\nexport let DefaultRoutingProvider: ReturnType<typeof createDefaultRoutingProvider>\nlet BugsnagPerformance: Client<BrowserConfiguration>\n\nif (typeof window === 'undefined' || typeof document === 'undefined') {\n  onSettle = createNoopOnSettle()\n  DefaultRoutingProvider = createNoopRoutingProvider()\n  BugsnagPerformance = createNoopClient()\n} else {\n  const backgroundingListener = createBrowserBackgroundingListener(window)\n  const spanAttributesSource = createSpanAttributesSource(document)\n  const clock = createClock(performance, backgroundingListener)\n  const persistence = makeBrowserPersistence(window)\n  const resourceAttributesSource = createResourceAttributesSource(navigator, persistence)\n  const fetchRequestTracker = createFetchRequestTracker(window, clock)\n  const xhrRequestTracker = createXmlHttpRequestTracker(XMLHttpRequest, clock, document)\n  const webVitals = new WebVitals(performance, clock, window.PerformanceObserver)\n  onSettle = createOnSettle(\n    clock,\n    window,\n    fetchRequestTracker,\n    xhrRequestTracker,\n    performance\n  )\n  DefaultRoutingProvider = createDefaultRoutingProvider(onSettle, window.location)\n\n  BugsnagPerformance = createClient({\n    backgroundingListener,\n    clock,\n    resourceAttributesSource,\n    spanAttributesSource,\n    deliveryFactory: createFetchDeliveryFactory(window.fetch, clock, backgroundingListener),\n    idGenerator,\n    schema: createSchema(window.location.hostname, new DefaultRoutingProvider()),\n    plugins: (spanFactory, spanContextStorage) => [\n      onSettle,\n      new FullPageLoadPlugin(\n        document,\n        window.location,\n        spanFactory,\n        webVitals,\n        onSettle,\n        backgroundingListener,\n        performance\n      ),\n      // ResourceLoadPlugin should always come after FullPageLoad plugin, as it should use that\n      // span context as the parent of it's spans\n      new ResourceLoadPlugin(spanFactory, spanContextStorage, window.PerformanceObserver),\n      new NetworkRequestPlugin(spanFactory, fetchRequestTracker, xhrRequestTracker),\n      new RouteChangePlugin(spanFactory, window.location, document)\n    ],\n    persistence,\n    retryQueueFactory: (delivery, retryQueueMaxSize) => new InMemoryQueue(delivery, retryQueueMaxSize)\n  })\n}\n\nexport default BugsnagPerformance\n","import DomMutationSettler from './dom-mutation-settler'\nimport LoadEventEndSettler, { type PerformanceWithTiming } from './load-event-end-settler'\nimport RequestSettler from './request-settler'\nimport SettlerAggregate from './settler-aggregate'\nimport { type BrowserConfiguration } from '../config'\nimport { type RequestTracker } from '@bugsnag/request-tracker-performance'\nimport { type Clock, type InternalConfiguration, type Plugin } from '@bugsnag/core-performance'\n\nexport type OnSettle = (callback: OnSettleCallback) => void\nexport type OnSettleCallback = (settledTime: number) => void\nexport type OnSettlePlugin = Plugin<BrowserConfiguration> & OnSettle\n\nconst TIMEOUT_MILLISECONDS = 60 * 1000\n\nexport function createNoopOnSettle (): OnSettlePlugin {\n  const noop = () => {}\n  noop.configure = () => {}\n  return noop as OnSettlePlugin\n}\n\nexport default function createOnSettle (\n  clock: Clock,\n  window: Window,\n  fetchRequestTracker: RequestTracker,\n  xhrRequestTracker: RequestTracker,\n  performance: PerformanceWithTiming\n): OnSettlePlugin {\n  const domMutationSettler = new DomMutationSettler(clock, window.document)\n  const fetchRequestSettler = new RequestSettler(clock, fetchRequestTracker)\n  const xhrRequestSettler = new RequestSettler(clock, xhrRequestTracker)\n  const loadEventEndSettler = new LoadEventEndSettler(\n    clock,\n    window.addEventListener,\n    performance,\n    window.document\n  )\n\n  const settler = new SettlerAggregate(clock, [\n    domMutationSettler,\n    loadEventEndSettler,\n    fetchRequestSettler,\n    xhrRequestSettler\n  ])\n\n  function onSettlePlugin (callback: OnSettleCallback): void {\n    const onSettle: OnSettleCallback = (settledTime: number) => {\n      clearTimeout(timeout)\n\n      // unsubscribe from the settler so we don't call the callback more than\n      // once\n      settler.unsubscribe(onSettle)\n\n      callback(settledTime)\n    }\n\n    const timeout = setTimeout(() => {\n      const settledTime = clock.now()\n\n      settler.unsubscribe(onSettle)\n\n      callback(settledTime)\n    }, TIMEOUT_MILLISECONDS)\n\n    // if we're already settled apply a 100ms \"cooldown\" period in case we\n    // unsettle immediately after this call\n    // if we're not settled then this cooldown is irrelevant - we can just\n    // subscribe to the settler to be notified of when the page settles\n    const cooldown = settler.isSettled() ? 100 : 0\n    const settledTime = clock.now()\n\n    setTimeout(() => {\n      if (settler.isSettled()) {\n        // if we're still settled call the callback via \"onSettle\"\n        onSettle(settledTime)\n      } else {\n        // otherwise wait for the page to settle\n        settler.subscribe(onSettle)\n      }\n    }, cooldown)\n  }\n\n  onSettlePlugin.configure = function (configuration: InternalConfiguration<BrowserConfiguration>): void {\n    const settleIgnoreUrls = configuration.settleIgnoreUrls.map(\n      (url: string | RegExp): RegExp => typeof url === 'string' ? RegExp(url) : url\n    ).concat(RegExp(configuration.endpoint))\n\n    fetchRequestSettler.setUrlsToIgnore(settleIgnoreUrls)\n    xhrRequestSettler.setUrlsToIgnore(settleIgnoreUrls)\n  }\n\n  return onSettlePlugin\n}\n","import { BatchProcessor } from './batch-processor.js';\nimport { validateConfig } from './config.js';\nimport { TracePayloadEncoder } from './delivery.js';\nimport ProbabilityFetcher from './probability-fetcher.js';\nimport ProbabilityManager from './probability-manager.js';\nimport { BufferingProcessor } from './processor.js';\nimport Sampler from './sampler.js';\nimport { DefaultSpanContextStorage } from './span-context.js';\nimport { SpanFactory } from './span-factory.js';\n\nfunction createClient(options) {\n    const bufferingProcessor = new BufferingProcessor();\n    let processor = bufferingProcessor;\n    const spanContextStorage = options.spanContextStorage || new DefaultSpanContextStorage(options.backgroundingListener);\n    let logger = options.schema.logger.defaultValue;\n    const sampler = new Sampler(1.0);\n    const spanFactory = new SpanFactory(processor, sampler, options.idGenerator, options.spanAttributesSource, options.clock, options.backgroundingListener, logger, spanContextStorage);\n    const plugins = options.plugins(spanFactory, spanContextStorage);\n    return Object.assign({ start: (config) => {\n            const configuration = validateConfig(config, options.schema);\n            const delivery = options.deliveryFactory(configuration.endpoint);\n            options.spanAttributesSource.configure(configuration);\n            ProbabilityManager.create(options.persistence, sampler, new ProbabilityFetcher(delivery, configuration.apiKey)).then((manager) => {\n                processor = new BatchProcessor(delivery, configuration, options.retryQueueFactory(delivery, configuration.retryQueueMaxSize), sampler, manager, new TracePayloadEncoder(options.clock, configuration, options.resourceAttributesSource));\n                // ensure all spans started before .start() are added to the batch\n                for (const span of bufferingProcessor.spans) {\n                    processor.add(span);\n                }\n                // register with the backgrounding listener - we do this in 'start' as\n                // there's nothing to do if we're backgrounded before start is called\n                // e.g. we can't trigger delivery until we have the apiKey and endpoint\n                // from configuration\n                options.backgroundingListener.onStateChange(state => {\n                    processor.flush();\n                });\n                logger = configuration.logger;\n                spanFactory.configure(processor, logger);\n            });\n            for (const plugin of configuration.plugins) {\n                plugins.push(plugin);\n            }\n            for (const plugin of plugins) {\n                plugin.configure(configuration, spanFactory);\n            }\n        }, startSpan: (name, spanOptions) => {\n            const cleanOptions = spanFactory.validateSpanOptions(name, spanOptions);\n            const span = spanFactory.startSpan(cleanOptions.name, cleanOptions.options);\n            span.setAttribute('bugsnag.span.category', 'custom');\n            return spanFactory.toPublicApi(span);\n        }, getPlugin: (Constructor) => {\n            for (const plugin of plugins) {\n                if (plugin instanceof Constructor) {\n                    return plugin;\n                }\n            }\n        }, get currentSpanContext() {\n            return spanContextStorage.current;\n        } }, (options.platformExtensions && options.platformExtensions(spanFactory, spanContextStorage)));\n}\nfunction createNoopClient() {\n    const noop = () => { };\n    return {\n        start: noop,\n        startSpan: () => ({ id: '', traceId: '', end: noop, isValid: () => false }),\n        currentSpanContext: undefined\n    };\n}\n\nexport { createClient, createNoopClient };\n","import {\n  type BackgroundingListener,\n  type BackgroundingListenerCallback,\n  type BackgroundingListenerState\n} from '@bugsnag/core-performance'\n\ninterface DocumentForVisibilityState {\n  addEventListener: (event: string, callback: () => void) => void\n  visibilityState: string\n}\n\ninterface WindowWithDocumentForVisibilityState {\n  document: DocumentForVisibilityState\n  addEventListener: (event: string, callback: () => void) => void\n}\n\nexport default function createBrowserBackgroundingListener (window: WindowWithDocumentForVisibilityState) {\n  const callbacks: BackgroundingListenerCallback[] = []\n  let state: BackgroundingListenerState = window.document.visibilityState === 'hidden'\n    ? 'in-background'\n    : 'in-foreground'\n\n  const backgroundingListener: BackgroundingListener = {\n    onStateChange (backgroundingListenerCallback: BackgroundingListenerCallback): void {\n      callbacks.push(backgroundingListenerCallback)\n\n      // trigger the callback immediately if the document is already 'hidden'\n      if (state === 'in-background') {\n        backgroundingListenerCallback(state)\n      }\n    }\n  }\n\n  const backgroundStateChanged = (newState: BackgroundingListenerState) => {\n    if (state === newState) return\n\n    state = newState\n    for (const callback of callbacks) {\n      callback(state)\n    }\n  }\n\n  window.document.addEventListener('visibilitychange', function () {\n    const newState = window.document.visibilityState === 'hidden'\n      ? 'in-background'\n      : 'in-foreground'\n\n    backgroundStateChanged(newState)\n  })\n\n  // some browsers don't fire the visibilitychange event when the page is suspended,\n  // so we also listen for pagehide and pageshow events\n  window.addEventListener('pagehide', function () {\n    backgroundStateChanged('in-background')\n  })\n\n  window.addEventListener('pageshow', function () {\n    backgroundStateChanged('in-foreground')\n  })\n\n  return backgroundingListener\n}\n","import type { InternalConfiguration, SpanAttributesSource, SpanInternal } from '@bugsnag/core-performance'\nimport { type BrowserConfiguration } from './config'\n\nexport const createSpanAttributesSource = (document: Document): SpanAttributesSource<BrowserConfiguration> => {\n  const defaultAttributes = {\n    url: {\n      name: 'bugsnag.browser.page.url',\n      getValue: () => document.location.href,\n      permitted: false\n    },\n    title: {\n      name: 'bugsnag.browser.page.title',\n      getValue: () => document.title,\n      permitted: false\n    }\n  }\n\n  return {\n    configure (configuration: InternalConfiguration<BrowserConfiguration>) {\n      defaultAttributes.title.permitted = configuration.sendPageAttributes.title || false\n      defaultAttributes.url.permitted = configuration.sendPageAttributes.url || false\n    },\n    requestAttributes (span: SpanInternal) {\n      for (const attribute of Object.values(defaultAttributes)) {\n        if (attribute.permitted) {\n          span.setAttribute(attribute.name, attribute.getValue())\n        }\n      }\n    }\n  }\n}\n\nexport default createSpanAttributesSource\n","import cuid from '@bugsnag/cuid'\nimport { ResourceAttributes, type Persistence, type ResourceAttributeSource } from '@bugsnag/core-performance'\nimport { type BrowserConfiguration } from './config'\n\nfunction createResourceAttributesSource (\n  navigator: Navigator,\n  persistence: Persistence\n): ResourceAttributeSource<BrowserConfiguration> {\n  let getDeviceId: Promise<string> | undefined\n  let deviceId: string | undefined\n\n  return function resourceAttributesSource (config) {\n    const attributes = new ResourceAttributes(\n      config.releaseStage,\n      config.appVersion,\n      'bugsnag.performance.browser',\n      '__VERSION__'\n    )\n\n    attributes.set('browser.user_agent', navigator.userAgent)\n\n    // chromium only\n    if (navigator.userAgentData) {\n      attributes.set('browser.platform', navigator.userAgentData.platform)\n      attributes.set('browser.mobile', navigator.userAgentData.mobile)\n    }\n\n    if (config.generateAnonymousId) {\n      // ensure we only load/generate the anonymous ID once no matter how many\n      // times we're called, otherwise we could generate different IDs on\n      // different calls as cuids are partly time based\n      if (!getDeviceId) {\n        getDeviceId = persistence.load('bugsnag-anonymous-id')\n          .then(maybeAnonymousId => {\n            // use the persisted value or generate a new ID\n            const anonymousId = maybeAnonymousId || cuid()\n\n            // if there was no persisted value, save the newly generated ID\n            if (!maybeAnonymousId) {\n              persistence.save('bugsnag-anonymous-id', anonymousId)\n            }\n\n            // store the device ID so we can set it synchronously in future\n            deviceId = anonymousId\n\n            return deviceId\n          })\n      }\n\n      if (deviceId) {\n        // set device ID synchronously if it's already available\n        attributes.set('device.id', deviceId)\n      } else {\n        // otherwise add it when the promise resolves\n        return getDeviceId\n          .then(deviceId => {\n            attributes.set('device.id', deviceId)\n\n            return attributes\n          })\n      }\n    }\n\n    return Promise.resolve(attributes)\n  }\n}\n\nexport default createResourceAttributesSource\n","import { RequestTracker } from './request-tracker.js';\nimport getAbsoluteUrl from './url-helpers.js';\n\nfunction createXmlHttpRequestTracker(xhr, clock, document) {\n    const requestTracker = new RequestTracker();\n    const trackedRequests = new WeakMap();\n    const requestHandlers = new WeakMap();\n    const originalOpen = xhr.prototype.open;\n    xhr.prototype.open = function open(method, url, ...rest) {\n        trackedRequests.set(this, { method, url: getAbsoluteUrl(String(url), document && document.baseURI) });\n        // @ts-expect-error rest\n        originalOpen.call(this, method, url, ...rest);\n    };\n    const originalSend = xhr.prototype.send;\n    xhr.prototype.send = function send(body) {\n        const requestData = trackedRequests.get(this);\n        if (requestData) {\n            // if there is an existing event listener this request instance is being reused,\n            // so we need to remove the listener from the previous send\n            const existingHandler = requestHandlers.get(this);\n            if (existingHandler)\n                this.removeEventListener('readystatechange', existingHandler);\n            const onRequestEnd = requestTracker.start({\n                type: 'xmlhttprequest',\n                method: requestData.method,\n                url: requestData.url,\n                startTime: clock.now()\n            });\n            const onReadyStateChange = (evt) => {\n                if (this.readyState === xhr.DONE && onRequestEnd) {\n                    // If the status is 0 the request did not complete so report this as an error\n                    const endContext = this.status > 0\n                        ? { endTime: clock.now(), status: this.status, state: 'success' }\n                        : { endTime: clock.now(), state: 'error' };\n                    onRequestEnd(endContext);\n                }\n            };\n            this.addEventListener('readystatechange', onReadyStateChange);\n            requestHandlers.set(this, onReadyStateChange);\n        }\n        originalSend.call(this, body);\n    };\n    return requestTracker;\n}\n\nexport { createXmlHttpRequestTracker as default };\n","import {\n  isBoolean,\n  isStringOrRegExpArray,\n  schema,\n  type ConfigOption,\n  type Configuration,\n  type CoreSchema\n} from '@bugsnag/core-performance'\nimport { type NetworkRequestCallback, defaultNetworkRequestCallback, isNetworkRequestCallback } from '@bugsnag/request-tracker-performance'\nimport { type BrowserNetworkRequestInfo } from './auto-instrumentation'\nimport { isRoutingProvider, type RoutingProvider } from './routing-provider'\nimport { defaultSendPageAttributes, isSendPageAttributes, type SendPageAttributes } from './send-page-attributes'\n\nexport interface BrowserSchema extends CoreSchema {\n  autoInstrumentFullPageLoads: ConfigOption<boolean>\n  autoInstrumentNetworkRequests: ConfigOption<boolean>\n  autoInstrumentRouteChanges: ConfigOption<boolean>\n  generateAnonymousId: ConfigOption<boolean>\n  routingProvider: ConfigOption<RoutingProvider>\n  settleIgnoreUrls: ConfigOption<Array<string | RegExp>>\n  networkRequestCallback: ConfigOption<NetworkRequestCallback<BrowserNetworkRequestInfo>>\n  sendPageAttributes: ConfigOption<SendPageAttributes>\n}\n\nexport interface BrowserConfiguration extends Configuration {\n  autoInstrumentFullPageLoads?: boolean\n  autoInstrumentNetworkRequests?: boolean\n  autoInstrumentRouteChanges?: boolean\n  generateAnonymousId?: boolean\n  routingProvider?: RoutingProvider\n  settleIgnoreUrls?: Array<string | RegExp>\n  networkRequestCallback?: NetworkRequestCallback<BrowserNetworkRequestInfo>\n  sendPageAttributes?: SendPageAttributes\n}\n\nexport function createSchema (hostname: string, defaultRoutingProvider: RoutingProvider): BrowserSchema {\n  return {\n    ...schema,\n    releaseStage: {\n      ...schema.releaseStage,\n      defaultValue: hostname === 'localhost' ? 'development' : 'production'\n    },\n    autoInstrumentFullPageLoads: {\n      defaultValue: true,\n      message: 'should be true|false',\n      validate: isBoolean\n    },\n    autoInstrumentNetworkRequests: {\n      defaultValue: true,\n      message: 'should be true|false',\n      validate: isBoolean\n    },\n    autoInstrumentRouteChanges: {\n      defaultValue: true,\n      message: 'should be true|false',\n      validate: isBoolean\n    },\n    generateAnonymousId: {\n      defaultValue: true,\n      message: 'should be true|false',\n      validate: isBoolean\n    },\n    routingProvider: {\n      defaultValue: defaultRoutingProvider,\n      message: 'should be a routing provider',\n      validate: isRoutingProvider\n    },\n    settleIgnoreUrls: {\n      defaultValue: [],\n      message: 'should be an array of string|RegExp',\n      validate: isStringOrRegExpArray\n    },\n    networkRequestCallback: {\n      defaultValue: defaultNetworkRequestCallback,\n      message: 'should be a function',\n      validate: isNetworkRequestCallback\n    },\n    sendPageAttributes: {\n      defaultValue: defaultSendPageAttributes,\n      message: 'should be an object',\n      validate: isSendPageAttributes\n    }\n  }\n}\n"],"names":["isBoolean","value","isObject","Array","isArray","isNumber","Number","isFinite","isNaN","isString","isStringWithLength","length","isStringOrRegExpArray","every","item","RegExp","isSpanContext","id","traceId","isValid","SpanAttributes","constructor","initialValues","this","attributes","set","name","remove","delete","toJson","from","map","key","attribute","isInteger","intValue","doubleValue","boolValue","stringValue","attributeToJson","ResourceAttributes","releaseStage","appVersion","sdkName","sdkVersion","Map","super","NANOSECONDS_IN_MILLISECONDS","schema","defaultValue","message","validate","endpoint","apiKey","test","logger","debug","console","info","warn","error","enabledReleaseStages","isStringArray","samplingProbability","plugins","plugin","configure","isPlugin","BatchProcessor","delivery","configuration","retryQueue","sampler","probabilityManager","encoder","batch","timeout","flush","bind","stop","clearTimeout","start","setTimeout","batchInactivityTimeoutMs","add","span","includes","push","maximumBatchSize","prepareBatch","payload","encode","batchTime","Date","now","response","send","undefined","setProbability","state","err","probability","spanProbability","raw","sample","SpanEvents","events","time","clock","timeUnixNano","toUnixTimestampNanoseconds","SpanInternal","startTime","parentSpanId","kind","samplingRate","i","position","parseInt","slice","traceIdToSamplingRate","addEvent","setAttribute","end","endTime","_samplingProbability","coreSpanOptionSchema","getDefaultValue","parentContext","makeCurrentContext","isFirstClass","TracePayloadEncoder","resourceAttributeSource","spans","resourceAttributes","jsonSpans","spanId","startTimeUnixNano","endTimeUnixNano","body","resourceSpans","resource","scopeSpans","headers","generateSamplingHeader","spanCounts","Object","create","existingValue","rawProbabilities","keys","pairs","rawProbability","join","retryCodes","Set","ProbabilityFetcher","getNewProbability","timeBetweenRetries","Promise","resolve","PROBABILITY_REFRESH_MILLISECONDS","ProbabilityManager","persistence","probabilityFetcher","persistedProbability","load","initialProbabilityTime","initialTimoutDuration","lastProbabilityTime","fetchNewProbabilityIn","newProbability","save","milliseconds","lastProbabilityTimeBeforeTimeout","async","BufferingProcessor","scaleProbabilityToMatchSamplingRate","Math","floor","Sampler","initialProbability","_probability","scaledProbability","scaled","DefaultSpanContextStorage","backgroundingListener","contextStack","isInForeground","onBackgroundStateChange","onStateChange","Symbol","iterator","context","pop","span1","span2","current","removeClosedContexts","first","timeToNumber","convert","SpanFactory","processor","idGenerator","spanAttributesSource","spanContextStorage","openSpans","WeakSet","startSpan","options","safeStartTime","generate","endSpan","requestAttributes","spanEnded","toPublicApi","safeEndTime","validateSpanOptions","warnings","cleanOptions","String","spanOptions","option","prototype","hasOwnProperty","call","InMemoryPersistence","persistedItems","get","toPersistedPayload","json","JSON","parse","isDeviceId","InMemoryQueue","retryQueueMaxSize","requestQueue","payloads","spanCount","reduce","count","countSpansInPayload","shift","then","j","samplingProbabilityFromHeaders","asNumber","parseFloat","defaultNetworkRequestCallback","networkRequestInfo","isNetworkRequestCallback","RequestTracker","callbacks","onStart","startCallback","endCallbacks","endCallback","endContext","getAbsoluteUrl","url","baseUrl","indexOf","absoluteUrl","URL","href","endsWith","_a","createStartContext","input","init","inputIsRequest","isRequest","method","type","defaultSendPageAttributes","referrer","title","getPermittedAttributes","sendPageAttributes","assign","isSendPageAttributes","obj","allowedTypes","defaultRouteResolver","pathname","createNoopRoutingProvider","resolveRoute","listenForRouteChanges","startRouteChangeSpan","createDefaultRoutingProvider","onSettle","location","addEventListener","ev","originalPushState","history","pushState","args","absoluteURL","toString","document","baseURI","apply","FullPageLoadPlugin","spanFactory","webVitals","performance","wasBackgrounded","autoInstrumentFullPageLoads","permittedAttributes","route","routingProvider","createPageLoadPhaseSpan","phase","shouldOmitSpan","entries","getEntriesByType","entry","unloadEventStart","unloadEventEnd","redirectStart","redirectEnd","fetchStart","domainLookupStart","domainLookupEnd","TCPHandshakeEnd","secureConnectionStart","connectEnd","connectStart","requestStart","responseStart","responseEnd","domContentLoadedEventStart","domContentLoadedEventEnd","loadEventStart","loadEventEnd","instrumentPageLoadPhaseSpans","attachTo","permittedPrefixes","NetworkRequestPlugin","fetchTracker","xhrTracker","configEndpoint","networkRequestCallback","trackRequest","startContext","shouldTrackRequest","toUpperCase","status","autoInstrumentNetworkRequests","some","prefix","startsWith","getHttpVersion","protocol","ResourceLoadPlugin","PerformanceObserverClass","supportedEntryTypes","observer","list","getEntries","initiatorType","search","httpFlavor","nextHopProtocol","encodedBodySize","decodedBodySize","responseStatus","observe","buffered","entryTypes","routeChangeSpanOptionSchema","trigger","RouteChangePlugin","autoInstrumentRouteChanges","previousUrl","previousRoute","stringUrl","routeChangeSpanOptions","endTimeOrOptions","urlObject","ensureUrl","MAX_CLOCK_DRIFT_MS","recalculateTimeOrigin","timeOrigin","abs","isRoutingProvider","toHex","hex","bits","bytes","Uint8Array","randomValues","window","crypto","getRandomValues","Settler","settled","subscribe","callback","isSettled","unsubscribe","settle","settledTime","DomMutationSettler","target","MutationObserver","restart","subtree","childList","characterData","LoadEventEndSettler","readyState","settleUsingPerformance","entryType","isPerformanceNavigationTiming","timing","navigationStart","RequestSettler","requestTracker","urlsToIgnore","outstandingRequests","onRequestStart","setUrlsToIgnore","shouldIgnoreUrl","regexp","SettlerAggregate","settlers","settler","settlersAreSettled","BrowserPersistence","localStorage","storage","getItem","setItem","stringify","getDefaultExportFromCjs","x","pad","num","size","s","substr","require$$0","env","self","globalCount","prop","clientId","navigator","mimeTypes","userAgent","fingerprint","require$$1","c","blockSize","base","discreteValues","pow","randomBlock","random","cuid","getTime","WebVitals","observers","observeLargestContentfulPaint","observeLayoutShift","firstContentfulPaint","timeToFirstByte","firstInputDelay","cumulativeLayoutShift","largestContentfulPaint","disconnect","getEntriesByName","processingStart","session","hadRecentInput","previousStartTime","firstStartTime","DefaultRoutingProvider","BugsnagPerformance","noop","createNoopOnSettle","currentSpanContext","createNoopClient","visibilityState","backgroundingListenerCallback","backgroundStateChanged","newState","createBrowserBackgroundingListener","defaultAttributes","getValue","permitted","values","createSpanAttributesSource","calculatedTimeOrigin","date","millisecondsToNanoseconds","round","createClock","makeBrowserPersistence","resourceAttributesSource","getDeviceId","deviceId","config","userAgentData","platform","mobile","generateAnonymousId","maybeAnonymousId","anonymousId","createResourceAttributesSource","fetchRequestTracker","global","originalFetch","fetch","onRequestEnd","catch","createFetchRequestTracker","xhrRequestTracker","xhr","trackedRequests","WeakMap","requestHandlers","originalOpen","open","rest","originalSend","requestData","existingHandler","removeEventListener","onReadyStateChange","evt","DONE","createXmlHttpRequestTracker","XMLHttpRequest","PerformanceObserver","domMutationSettler","fetchRequestSettler","xhrRequestSettler","loadEventEndSettler","onSettlePlugin","cooldown","settleIgnoreUrls","concat","createOnSettle","bufferingProcessor","Error","cleanConfiguration","validateConfig","deliveryFactory","manager","retryQueueFactory","getPlugin","Constructor","platformExtensions","createClient","keepalive","toISOString","statusCode","has","createFetchDeliveryFactory","hostname","defaultRoutingProvider","BugsnagPerformance$1"],"mappings":"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","x_google_ignoreList":[39,40,41]}